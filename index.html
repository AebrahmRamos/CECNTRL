<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CECNTRL T2 2025-26 ‚Äî Exam Reviewer</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Space+Grotesk:wght@400;500;600;700&family=Instrument+Serif:ital@0;1&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0e17;
  --surface: #111827;
  --surface2: #1a2234;
  --border: #1e2d44;
  --accent: #3b82f6;
  --accent2: #06b6d4;
  --accent3: #8b5cf6;
  --green: #22c55e;
  --amber: #f59e0b;
  --red: #ef4444;
  --text: #e2e8f0;
  --text-dim: #94a3b8;
  --text-bright: #f8fafc;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html { scroll-behavior: smooth; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Space Grotesk', sans-serif;
  line-height: 1.7;
  font-size: 15px;
}

/* Scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

/* Navigation */
.nav {
  position: fixed;
  top: 0;
  left: 0;
  width: 260px;
  height: 100vh;
  background: var(--surface);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  z-index: 100;
  padding: 24px 0;
}
.nav-header {
  padding: 0 20px 20px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 16px;
}
.nav-header h2 {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 13px;
  color: var(--accent);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 4px;
}
.nav-header p {
  font-size: 11px;
  color: var(--text-dim);
}
.nav-section {
  padding: 8px 20px;
}
.nav-section-title {
  font-size: 10px;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 8px;
  font-weight: 600;
}
.nav a {
  display: block;
  padding: 6px 12px;
  color: var(--text-dim);
  text-decoration: none;
  font-size: 13px;
  border-radius: 6px;
  transition: all 0.2s;
  margin-bottom: 2px;
}
.nav a:hover {
  background: var(--surface2);
  color: var(--text-bright);
}
.nav a.active {
  background: rgba(59,130,246,0.12);
  color: var(--accent);
}

/* Main content */
.main {
  margin-left: 260px;
  padding: 40px 60px 100px;
  max-width: 1000px;
}

/* Hero */
.hero {
  margin-bottom: 60px;
  padding-bottom: 40px;
  border-bottom: 1px solid var(--border);
}
.hero-badge {
  display: inline-block;
  background: linear-gradient(135deg, var(--accent), var(--accent3));
  color: white;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  padding: 4px 12px;
  border-radius: 20px;
  margin-bottom: 16px;
}
.hero h1 {
  font-family: 'Instrument Serif', serif;
  font-size: 48px;
  line-height: 1.15;
  color: var(--text-bright);
  margin-bottom: 12px;
}
.hero p {
  font-size: 16px;
  color: var(--text-dim);
  max-width: 600px;
}

/* Section */
.section {
  margin-bottom: 56px;
  scroll-margin-top: 24px;
}
.section h2 {
  font-family: 'Instrument Serif', serif;
  font-size: 32px;
  color: var(--text-bright);
  margin-bottom: 6px;
}
.section-num {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 12px;
  color: var(--accent);
  letter-spacing: 1px;
  margin-bottom: 8px;
  display: block;
}
.section > p, .section > .content > p {
  margin-bottom: 16px;
  color: var(--text);
}

/* Cards */
.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px;
  margin-bottom: 20px;
}
.card h3 {
  font-size: 17px;
  font-weight: 600;
  color: var(--text-bright);
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.card h3 .icon {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  flex-shrink: 0;
}
.card h3 .icon.blue { background: rgba(59,130,246,0.15); color: var(--accent); }
.card h3 .icon.cyan { background: rgba(6,182,212,0.15); color: var(--accent2); }
.card h3 .icon.purple { background: rgba(139,92,246,0.15); color: var(--accent3); }
.card h3 .icon.green { background: rgba(34,197,94,0.15); color: var(--green); }
.card h3 .icon.amber { background: rgba(245,158,11,0.15); color: var(--amber); }
.card h3 .icon.red { background: rgba(239,68,68,0.15); color: var(--red); }

/* Key-value pairs */
.kv-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin: 16px 0;
}
.kv {
  background: var(--surface2);
  border-radius: 8px;
  padding: 12px 16px;
}
.kv-label {
  font-size: 11px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 4px;
}
.kv-value {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 14px;
  color: var(--text-bright);
}

/* Tables */
.table-wrap {
  overflow-x: auto;
  margin: 16px 0;
}
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}
thead th {
  background: var(--surface2);
  padding: 10px 14px;
  text-align: left;
  font-size: 11px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
}
tbody td {
  padding: 10px 14px;
  border-bottom: 1px solid var(--border);
  color: var(--text);
}
tbody tr:hover { background: rgba(59,130,246,0.04); }
td code, p code, li code {
  font-family: 'IBM Plex Mono', monospace;
  background: var(--surface2);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 13px;
  color: var(--accent2);
}

/* Timing diagram (SVG style) */
.timing-diagram {
  background: var(--surface2);
  border-radius: 10px;
  padding: 20px;
  margin: 16px 0;
  overflow-x: auto;
}
.timing-diagram svg {
  display: block;
  width: 100%;
  height: auto;
}

/* Callout / Alert */
.callout {
  border-left: 3px solid var(--accent);
  background: rgba(59,130,246,0.06);
  padding: 16px 20px;
  border-radius: 0 8px 8px 0;
  margin: 16px 0;
  font-size: 14px;
}
.callout.warn {
  border-left-color: var(--amber);
  background: rgba(245,158,11,0.06);
}
.callout.tip {
  border-left-color: var(--green);
  background: rgba(34,197,94,0.06);
}
.callout strong {
  color: var(--text-bright);
}

/* Lists */
ul, ol {
  margin: 12px 0 12px 20px;
}
li {
  margin-bottom: 6px;
  color: var(--text);
}
li strong { color: var(--text-bright); }

/* Pin diagram */
.pin-diagram {
  background: var(--surface2);
  border-radius: 10px;
  padding: 24px;
  margin: 16px 0;
  display: flex;
  justify-content: center;
}
.chip {
  background: var(--surface);
  border: 2px solid var(--border);
  border-radius: 8px;
  padding: 16px 40px;
  position: relative;
  min-width: 200px;
  text-align: center;
}
.chip-name {
  font-family: 'IBM Plex Mono', monospace;
  font-weight: 600;
  font-size: 18px;
  color: var(--accent);
}
.chip-desc {
  font-size: 12px;
  color: var(--text-dim);
}

/* Flow diagrams */
.flow {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  margin: 16px 0;
}
.flow-step {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 16px;
  font-size: 13px;
  color: var(--text);
  white-space: nowrap;
}
.flow-arrow {
  color: var(--accent);
  font-size: 18px;
}

/* Comparison grid */
.compare {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin: 16px 0;
}
.compare-col {
  background: var(--surface2);
  border-radius: 10px;
  padding: 20px;
}
.compare-col h4 {
  font-family: 'IBM Plex Mono', monospace;
  font-size: 15px;
  color: var(--accent);
  margin-bottom: 12px;
}

/* Mobile */
@media (max-width: 900px) {
  .nav { display: none; }
  .main { margin-left: 0; padding: 24px 20px; }
  .hero h1 { font-size: 32px; }
  .kv-grid { grid-template-columns: 1fr; }
  .compare { grid-template-columns: 1fr; }
}

/* Highlight */
mark {
  background: rgba(245,158,11,0.2);
  color: var(--amber);
  padding: 1px 4px;
  border-radius: 3px;
}

/* Subsection */
.subsection {
  margin-top: 32px;
  margin-bottom: 24px;
}
.subsection h3 {
  font-size: 20px;
  font-weight: 600;
  color: var(--text-bright);
  margin-bottom: 8px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}
</style>
</head>
<body>

<!-- Navigation -->
<nav class="nav">
  <div class="nav-header">
    <h2>CECNTRL</h2>
    <p>T2 AY2025-26 ¬∑ Exam Reviewer</p>
  </div>
  <div class="nav-section">
    <div class="nav-section-title">Module 1</div>
    <a href="#intel-systems">Intel-Based Systems</a>
    <a href="#8086-pins">8086/8088 Pins & Modes</a>
    <a href="#8284-clock">8284 Clock Generator</a>
    <a href="#bus-demux">Bus Demultiplexing</a>
    <a href="#timing">Timing Analysis</a>
    <a href="#8086-databus">8086 16-bit Data Bus</a>
  </div>
  <div class="nav-section">
    <div class="nav-section-title">Module 2</div>
    <a href="#dram-tech">DRAM Technology</a>
    <a href="#dram-timing">DRAM Timing</a>
    <a href="#dram-refresh">DRAM Refresh</a>
    <a href="#dram-page">Page Mode</a>
  </div>
  <div class="nav-section">
    <div class="nav-section-title">Module 3</div>
    <a href="#interrupts">Interrupt System</a>
    <a href="#8259">8259 PIC</a>
  </div>
  <div class="nav-section">
    <div class="nav-section-title">Module 4</div>
    <a href="#dma">DMA (8237)</a>
  </div>
  <div class="nav-section">
    <div class="nav-section-title">Module 5</div>
    <a href="#pc-arch">PC/XT Architecture</a>
    <a href="#modern-dram">Modern DRAM & DDR</a>
  </div>
  <div class="nav-section">
    <div class="nav-section-title">Reference</div>
    <a href="#formulas">Key Formulas</a>
    <a href="#quickref">Quick Reference</a>
  </div>
  <div class="nav-section">
    <div class="nav-section-title">Study Guide</div>
    <a href="#coverage-audit">Coverage Audit</a>
    <a href="#why-it-matters">Why It Matters</a>
    <a href="#study-strategy">How to Review</a>
  </div>
  <div class="nav-section">
    <div class="nav-section-title">Practice Exam</div>
    <a href="#practice-ident">Identification</a>
    <a href="#practice-timing">Timing Problems</a>
    <a href="#practice-design">Design & Analysis</a>
  </div>
</nav>

<!-- Main Content -->
<div class="main">

  <!-- Hero -->
  <div class="hero">
    <span class="hero-badge">Major Quiz 1 Reviewer</span>
    <h1>Introduction to Microcontrollers<br>& Applications</h1>
    <p>CECNTRL T2 AY2025-26 ¬∑ Instructor: Clement Ong ¬∑ Covers Weeks 1‚Äì6: Intel 8086/88, DRAM Technologies, PC Architecture, Interrupts, DMA, Modern DRAM</p>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- MODULE 1: Intel-Based Microprocessor Systems -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="section" id="intel-systems">
    <span class="section-num">01 ¬∑ INTEL-BASED MICROPROCESSOR SYSTEMS</span>
    <h2>The 8086/8088 Microprocessor</h2>

    <div class="card" style="border-color:rgba(96,165,250,0.3); background:linear-gradient(135deg, var(--surface), rgba(96,165,250,0.04));">
      <h3><span class="icon accent">‚òÖ</span> The Big Picture: What IS the 8088 System?</h3>
      <p>The Intel 8088 is a CPU ‚Äî but it can't work alone. It needs a team of helper chips to form a complete microcomputer system. Here's why:</p>
      <div class="kv-grid" style="margin-top:12px;">
        <div class="kv">
          <div class="kv-label">The Pin Problem</div>
          <div class="kv-value">The 8088 only has 40 pins on its chip package. It needs 20 pins for addresses (to talk to 1 MB of memory) and 8 pins for data ‚Äî but 20+8 = 28 pins just for buses, leaving almost nothing for control signals. <strong>Intel's solution: share the same 8 pins for both address and data</strong> (multiplexed bus, pins AD0‚ÄìAD7). During T1 of a bus cycle, these pins carry the address; during T2‚ÄìT4, they carry data. But this means you need an external chip to "catch" the address before data appears.</div>
        </div>
        <div class="kv">
          <div class="kv-label">The Helper Chips</div>
          <div class="kv-value">
            ‚Ä¢ <strong>8284 Clock Generator:</strong> Takes a crystal and produces the CLK signal that drives the CPU. Also produces PCLK for peripherals and synchronizes the READY and RESET signals.<br>
            ‚Ä¢ <strong>74LS373 Octal Latch (√ó2):</strong> Catches and holds the address from AD0‚ÄìAD7 when ALE fires, so the address stays stable while data appears on the same pins. A second latch buffers A8‚ÄìA15 for drive strength.<br>
            ‚Ä¢ <strong>74LS245 Bus Transceiver:</strong> Bidirectional data buffer. Amplifies the data bus signals so the CPU doesn't have to drive all the memory and I/O chips directly.<br>
            ‚Ä¢ <strong>74LS138 Decoder:</strong> Takes the upper address bits and generates chip-select signals to enable specific memory or I/O chips.
          </div>
        </div>
        <div class="kv">
          <div class="kv-label">The Data Flow</div>
          <div class="kv-value"><strong>Crystal ‚Üí 8284 ‚Üí CLK ‚Üí 8088 CPU ‚Üí AD0‚ÄìAD7 (multiplexed) ‚Üí 74LS373 (latches address) ‚Üí Address Bus ‚Üí Memory/IO</strong><br>On the data side: <strong>Memory/IO ‚Üí Data Bus ‚Üí 74LS245 (buffer) ‚Üí 8088 CPU</strong><br>Control signals (MEMR', MEMW', IOR', IOW') are generated from the CPU's RD', WR', and IO/M' pins via simple logic gates.</div>
        </div>
      </div>
      <div class="callout tip" style="margin-top:12px;">
        <strong>Think of it this way:</strong> The 8088 is the brain. The 8284 is the heartbeat. The 74LS373s are the brain's short-term memory for addresses. The 74LS245 is a megaphone for data. The 74LS138 is the receptionist deciding which chip gets talked to.
      </div>
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> Components of a Microprocessor-Based System</h3>
      <ul>
        <li><strong>Clock Generator</strong> ‚Äî produces time pulses to synchronize events</li>
        <li><strong>Microprocessor / CPU</strong> ‚Äî executes instructions, performs ALU operations</li>
        <li><strong>Memory</strong> ‚Äî stores program instructions and data</li>
        <li><strong>I/O Devices</strong> ‚Äî interfaces to the outside world</li>
      </ul>
      <p style="margin-top:12px;">Interconnection is via three buses: <strong>Address Bus</strong> (unidirectional), <strong>Data Bus</strong> (bidirectional), and <strong>Control Bus</strong> (mixed direction).</p>
    </div>

    <div class="compare">
      <div class="compare-col">
        <h4>Intel 8086 (1978)</h4>
        <ul>
          <li>16-bit internal & external data bus</li>
          <li>20-bit address lines ‚Üí 1 MB addressable</li>
          <li>5 MHz clock</li>
          <li>Has <code>BHE'</code> pin for byte selection</li>
          <li><code>M/IO'</code> ‚Äî memory vs I/O select</li>
        </ul>
      </div>
      <div class="compare-col">
        <h4>Intel 8088 (1979)</h4>
        <ul>
          <li>16-bit internal, <mark>8-bit external</mark> data bus</li>
          <li>20-bit address lines ‚Üí 1 MB addressable</li>
          <li>4.77 MHz in IBM PC/XT</li>
          <li>No <code>BHE'</code> ‚Äî replaced by <code>SSO'</code></li>
          <li><code>IO/M'</code> ‚Äî <mark>inverted</mark> from 8086</li>
        </ul>
      </div>
    </div>

    <div class="callout tip">
      <strong>Trivia (from lecture):</strong> Texas Instruments released the first 16-bit microprocessor ‚Äî the TMS9900 ‚Äî in 1976, two years before the 8086.
    </div>
  </div>

  <!-- 8086/8088 Pins -->
  <div class="section" id="8086-pins">
    <span class="section-num">01.1 ¬∑ PIN DESCRIPTIONS</span>
    <h2>8086/8088 Pin Functions</h2>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> Key Pin Groups</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>Pin</th><th>Function</th><th>Mode</th></tr>
          </thead>
          <tbody>
            <tr><td><code>CLK</code></td><td>Clock input from 8284</td><td>Both</td></tr>
            <tr><td><code>READY</code></td><td>Wait state input ‚Äî forces Tw states when low</td><td>Both</td></tr>
            <tr><td><code>RESET</code></td><td>System reset; forces CS=FFFFh, IP=0000h</td><td>Both</td></tr>
            <tr><td><code>AD0‚ÄìAD15</code> (8086)<br><code>AD0‚ÄìAD7</code> (8088)</td><td>Multiplexed address/data bus</td><td>Both</td></tr>
            <tr><td><code>A16/S3‚ÄìA19/S6</code></td><td>Upper address bits multiplexed with status</td><td>Both</td></tr>
            <tr><td><code>MN/MX'</code></td><td>Selects minimum or maximum mode</td><td>Both</td></tr>
            <tr><td><code>RD'</code></td><td>Read strobe for memory or I/O</td><td>Both</td></tr>
            <tr><td><code>WR'</code></td><td>Write strobe for memory or I/O</td><td>Min</td></tr>
            <tr><td><code>M/IO'</code> (8086)<br><code>IO/M'</code> (8088)</td><td>Selects memory or I/O access</td><td>Min</td></tr>
            <tr><td><code>ALE</code></td><td>Address Latch Enable ‚Äî indicates address on bus</td><td>Min</td></tr>
            <tr><td><code>DEN'</code></td><td>Data Enable ‚Äî activates external data bus buffers</td><td>Min</td></tr>
            <tr><td><code>DT/R'</code></td><td>Data Transmit/Receive ‚Äî direction control</td><td>Min</td></tr>
            <tr><td><code>HOLD/HOLDA</code></td><td>DMA bus request / acknowledge</td><td>Min</td></tr>
            <tr><td><code>INTR</code></td><td>Maskable interrupt request</td><td>Min</td></tr>
            <tr><td><code>INTA'</code></td><td>Interrupt acknowledge</td><td>Min</td></tr>
            <tr><td><code>NMI</code></td><td>Non-maskable interrupt</td><td>Both</td></tr>
            <tr><td><code>BHE'/S7</code></td><td>Bus High Enable ‚Äî selects upper byte bank (8086 only)</td><td>Min</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="callout warn">
      <strong>Exam tip (from lecture):</strong> Remember that <code>M/IO'</code> on the 8086 is <em>inverted</em> to <code>IO/M'</code> on the 8088. Also, 8088 has no <code>BHE'</code> since it only has an 8-bit external data bus.
    </div>
  </div>

  <!-- 8284 Clock Generator -->
  <div class="section" id="8284-clock">
    <span class="section-num">01.2 ¬∑ CLOCK GENERATION</span>
    <h2>8284 Clock Generator</h2>

    <p>The 8086/8088 does <strong>not</strong> have an internal clock generator. The 8284 is an ancillary chip that provides clock, reset, and ready synchronization.</p>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> 8284 Functions & Outputs</h3>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">CLK Output</div>
          <div class="kv-value">33% duty cycle, f_crystal √∑ 3</div>
        </div>
        <div class="kv">
          <div class="kv-label">PCLK Output</div>
          <div class="kv-value">50% duty cycle, f_crystal √∑ 6</div>
        </div>
        <div class="kv">
          <div class="kv-label">OSC Output</div>
          <div class="kv-value">Raw crystal oscillator frequency</div>
        </div>
        <div class="kv">
          <div class="kv-label">RESET Output</div>
          <div class="kv-value">Synchronized reset to CPU from RC input</div>
        </div>
        <div class="kv">
          <div class="kv-label">READY Output</div>
          <div class="kv-value">Synchronized wait state to CPU</div>
        </div>
        <div class="kv">
          <div class="kv-label">Crystal Pins</div>
          <div class="kv-value">X1, X2 ‚Äî connect crystal; F/C' selects mode</div>
        </div>
      </div>
    </div>

    <div class="callout">
      <strong>Example:</strong> For an 8088 at 4.77 MHz ‚Üí Crystal frequency = 4.77 √ó 3 = <strong>14.318 MHz</strong>. PCLK = 14.318 / 6 ‚âà <strong>2.386 MHz</strong>.
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> 8284 Key Pins</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Pin</th><th>Description</th></tr></thead>
          <tbody>
            <tr><td><code>AEN1', AEN2'</code></td><td>Qualifier for bus ready signals</td></tr>
            <tr><td><code>RDY1, RDY2</code></td><td>Ready inputs ‚Äî used with AENx' for wait state generation</td></tr>
            <tr><td><code>ASYNC</code></td><td>Selects 1 or 2-stage synchronization for RDY inputs</td></tr>
            <tr><td><code>EFI</code></td><td>External frequency input (alternative to crystal)</td></tr>
            <tr><td><code>CSYNC</code></td><td>Used for multi-processor clock synchronization</td></tr>
            <tr><td><code>RES'</code></td><td>Reset input ‚Äî connected to RC network</td></tr>
          </tbody>
        </table>
      </div>

    <div class="callout warn">
      <strong>üéØ Exam Alert (from Jan 8 lecture):</strong> Sir Clem explicitly said: <em>"Quiz number one, problem one ‚Äî design a divide-by-3 circuit."</em> The 8284 uses divide-by-3 internally. This is NOT trivial in binary ‚Äî powers of 2 are easy (√∑2, √∑4, √∑8) but √∑3 requires a state machine (e.g., a 2-bit counter that counts 0‚Üí1‚Üí2‚Üí0 with asymmetric output). Know how to design one.
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> Why 33% Duty Cycle? (Critical Concept)</h3>
      <p>The 8088 datasheet specifies that the <strong>low portion of CLK must be approximately 2√ó longer than the high portion</strong> (~1/3 high, ~2/3 low). This asymmetric requirement is why a simple 50% duty cycle clock won't work:</p>

      <!-- 33% vs 50% duty cycle SVG -->
      <svg viewBox="0 0 700 200" style="width:100%; max-width:700px; margin:16px auto; display:block;">
        <style>
          .clk-line { stroke: #3b82f6; stroke-width: 2; fill: none; }
          .bad-line { stroke: #ef4444; stroke-width: 2; fill: none; }
          .dim-line { stroke: rgba(255,255,255,0.15); stroke-width: 1; }
          .label { fill: #94a3b8; font-size: 11px; font-family: 'IBM Plex Mono', monospace; }
          .ok { fill: #22c55e; font-size: 10px; font-family: 'IBM Plex Mono', monospace; }
          .bad { fill: #ef4444; font-size: 10px; font-family: 'IBM Plex Mono', monospace; }
          .ann { fill: #64748b; font-size: 9px; font-family: 'IBM Plex Mono', monospace; }
        </style>
        <!-- Labels -->
        <text x="10" y="30" class="label">33% CLK</text>
        <text x="10" y="30" class="label" transform="translate(0,90)">(correct)</text>
        <text x="10" y="120" class="label">50% CLK</text>
        <text x="10" y="120" class="label" transform="translate(0,12)">(WRONG)</text>

        <!-- 33% duty cycle waveform -->
        <polyline class="clk-line" points="80,50 80,15 150,15 150,50 290,50 290,15 360,15 360,50 500,50 500,15 570,15 570,50 680,50"/>
        <!-- Annotations -->
        <line x1="80" y1="58" x2="150" y2="58" stroke="#22c55e" stroke-width="1.5"/>
        <text x="105" y="72" class="ok">1/3 T</text>
        <line x1="150" y1="58" x2="290" y2="58" stroke="#22c55e" stroke-width="1.5"/>
        <text x="205" y="72" class="ok">2/3 T ‚úì</text>

        <!-- min tCL annotation -->
        <line x1="150" y1="55" x2="150" y2="75" stroke="rgba(255,255,255,0.3)" stroke-width="0.5" stroke-dasharray="2"/>
        <line x1="290" y1="55" x2="290" y2="75" stroke="rgba(255,255,255,0.3)" stroke-width="0.5" stroke-dasharray="2"/>

        <!-- 50% duty cycle waveform -->
        <polyline class="bad-line" points="80,140 80,105 185,105 185,140 290,140 290,105 395,105 395,140 500,140 500,105 605,105 605,140 680,140"/>
        <!-- Annotations -->
        <line x1="80" y1="148" x2="185" y2="148" stroke="#ef4444" stroke-width="1.5"/>
        <text x="120" y="163" class="ok">1/2 T</text>
        <line x1="185" y1="148" x2="290" y2="148" stroke="#ef4444" stroke-width="1.5"/>
        <text x="220" y="163" class="bad">1/2 T ‚úó</text>
        <text x="220" y="175" class="ann">too short!</text>

        <!-- min tCL line -->
        <line x1="185" y1="143" x2="320" y2="143" stroke="#ef4444" stroke-width="0.5" stroke-dasharray="3"/>
        <text x="325" y="147" class="bad">‚Üê min tCL required</text>
      </svg>

      <p>With a 50% duty cycle at 5 MHz, the low period = 100 ns. But the 8088 requires t<sub>CL</sub>(min) ‚âà 118 ns. <strong>Violation!</strong> To use 50% duty cycle, you must lower the frequency until t<sub>CL</sub> ‚â• 118 ns ‚Üí max freq ‚âà <strong>4.2 MHz</strong> (1/(2 √ó 118ns)).</p>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> 8284 Internal Signal Path</h3>
      <p>From the Jan 8 lecture ‚Äî the signal flow inside the 8284:</p>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">X1/X2 ‚Üí OSC</div>
          <div class="kv-value">Crystal oscillator output (raw frequency, goes directly to OSC pin)</div>
        </div>
        <div class="kv">
          <div class="kv-label">F/C' Select</div>
          <div class="kv-value">LOW = use crystal (OSC); HIGH = use EFI (external frequency input)</div>
        </div>
        <div class="kv">
          <div class="kv-label">Selected ‚Üí √∑3 ‚Üí CLK</div>
          <div class="kv-value">Divide-by-3 produces 33% duty cycle processor clock</div>
        </div>
        <div class="kv">
          <div class="kv-label">CLK ‚Üí √∑2 ‚Üí PCLK</div>
          <div class="kv-value">CLK is further halved for peripheral clock (50% duty cycle)</div>
        </div>
        <div class="kv">
          <div class="kv-label">RES' (active low) ‚Üí RESET (active high)</div>
          <div class="kv-value">RC network on RES' input; 8284 inverts and synchronizes for CPU</div>
        </div>
      </div>
      <p style="margin-top:12px; color:var(--text-dim); font-size:13px;"><strong>Connection note (F/C'):</strong> Normally grounded (logic 0) to select crystal oscillator. Standard: crystal with 510Œ© resistors on X1/X2.</p>
    </div>

    </div>

  <!-- Bus Demultiplexing -->
  <div class="section" id="bus-demux">
    <span class="section-num">01.3 ¬∑ BUS DEMULTIPLEXING</span>
    <h2>Address/Data Demultiplexing</h2>

    <p>Since the 8088's lower address and data share the same pins (AD0‚ÄìAD7), we must <strong>demultiplex</strong> them using latches and buffers controlled by <code>ALE</code>, <code>DEN'</code>, and <code>DT/R'</code>.</p>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> Demultiplexing Circuit (8088 Min Mode)</h3>
      <ul>
        <li><strong>3√ó 74LS373 Octal Latches</strong> ‚Äî latch address on ALE falling edge:
          <ul>
            <li>Latch 1: AD0‚ÄìAD7 ‚Üí A0‚ÄìA7 (also provides buffering)</li>
            <li>Latch 2: A8‚ÄìA15 (already address-only but latched for timing symmetry and drive)</li>
            <li>Latch 3: A16/S3‚ÄìA19/S6 ‚Üí A16‚ÄìA19 (upper 4 bits used, lower 4 wasted)</li>
          </ul>
        </li>
        <li><strong>1√ó 74LS245 Bidirectional Buffer</strong> ‚Äî data bus buffer:
          <ul>
            <li><code>E'</code> (enable) connected to <code>DEN'</code></li>
            <li><code>DIR</code> connected to <code>DT/R'</code></li>
          </ul>
        </li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Control Line Generation</h3>
      <p>The 8088 produces generic <code>RD'</code>, <code>WR'</code>, and <code>IO/M'</code>. We combine these with logic gates to produce the 4 specific control signals:</p>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Signal</th><th>Derivation</th><th>Purpose</th></tr></thead>
          <tbody>
            <tr><td><code>MEMR'</code></td><td><code>IO/M'</code> (inverted) AND <code>RD'</code></td><td>Memory Read</td></tr>
            <tr><td><code>MEMW'</code></td><td><code>IO/M'</code> (inverted) AND <code>WR'</code></td><td>Memory Write</td></tr>
            <tr><td><code>IOR'</code></td><td><code>IO/M'</code> AND <code>RD'</code></td><td>I/O Read</td></tr>
            <tr><td><code>IOW'</code></td><td><code>IO/M'</code> AND <code>WR'</code></td><td>I/O Write</td></tr>
          </tbody>
        </table>
      </div>
      <div class="callout warn">
        <strong>Reminder from lecture:</strong> Gates add <strong>propagation delay</strong>. When computing timing specifications, you must always <em>include</em> gate propagation delay in your calculations.
      </div>
    </div>

    <div class="callout tip">
      <strong>From Jan 8 lecture ‚Äî Why does A8-A15 have a 373 latch?</strong> These pins are address-only (not multiplexed), so technically no latch is needed. The 373 is used for two reasons: (1) <strong>timing uniformity</strong> ‚Äî all address lines arrive at memory with identical propagation delay, and (2) <strong>current buffering</strong> ‚Äî "without some kind of buffering, the 8088 itself will not have enough capacity to push the required currents" to drive many memory/IO chips. A 244 buffer would also work, but using a 373 keeps the electrical characteristics uniform across all address groups.
    </div>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> Data Bus Buffer Control: DEN' and DT/R'</h3>
      <p>The 8086 has two signals specifically for controlling the 74LS245 bidirectional data buffer (these do NOT exist on the HC11):</p>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">DEN' (Data Enable)</div>
          <div class="kv-value"><strong>When</strong> to activate the buffer. Connected to 245's enable pin. Goes active only during the data transfer portion of the bus cycle.</div>
        </div>
        <div class="kv">
          <div class="kv-label">DT/R' (Data Transmit/Receive)</div>
          <div class="kv-value"><strong>Which direction</strong> data flows. Connected to 245's DIR pin. HIGH = CPU‚Üímemory (write), LOW = memory‚ÜíCPU (read). Established early in the bus cycle before DEN' activates.</div>
        </div>
      </div>
      <p style="margin-top:8px; color:var(--text-dim); font-size:13px;">Sir Clem (Jan 8): <em>"If you're going to be putting a data buffer on the data bus, what signals do you need? When to buffer, and what direction."</em></p>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> IO/M' vs M/IO' ‚Äî The Inverted Signal</h3>
      <p>One of the few pin differences between the 8088 and 8086 (besides the data bus width):</p>
      <div class="table-wrap">
        <table>
          <thead><tr><th>CPU</th><th>Pin Name</th><th>Memory Operation</th><th>I/O Operation</th></tr></thead>
          <tbody>
            <tr><td><strong>8088</strong></td><td><code>IO/M'</code></td><td>LOW</td><td>HIGH</td></tr>
            <tr><td><strong>8086</strong></td><td><code>M/IO'</code></td><td>HIGH</td><td>LOW</td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:8px;">The signals are <strong>inverted</strong> in polarity. This means the control line generation logic must account for which CPU you're using. The 8088 also lacks BHE' (not needed for 8-bit bus). Sir Clem (Jan 8): <em>"They inverted that signal for some weird reason."</em></p>
    </div>

  </div>

  <!-- Timing Analysis -->
  <div class="section" id="timing">
    <span class="section-num">01.4 ¬∑ TIMING ANALYSIS</span>
    <h2>8088 Bus Cycle Timing</h2>

    <p>A standard bus cycle consists of <strong>4 T-states</strong> (T1‚ÄìT4). If the memory/IO device is slow, <strong>Tw</strong> (wait) states are inserted between T3 and T4.</p>

    <div class="timing-diagram">
      <svg viewBox="0 0 700 320" xmlns="http://www.w3.org/2000/svg">
        <!-- Background grid -->
        <defs>
          <pattern id="grid" width="87.5" height="40" patternUnits="userSpaceOnUse">
            <path d="M 87.5 0 L 87.5 320" fill="none" stroke="#1e2d44" stroke-width="0.5" stroke-dasharray="4,4"/>
          </pattern>
        </defs>
        <rect width="700" height="320" fill="#111827" rx="8"/>
        <rect x="100" y="0" width="600" height="320" fill="url(#grid)"/>

        <!-- T-state labels -->
        <text x="143" y="20" fill="#94a3b8" font-size="12" font-family="IBM Plex Mono" text-anchor="middle">T1</text>
        <text x="231" y="20" fill="#94a3b8" font-size="12" font-family="IBM Plex Mono" text-anchor="middle">T2</text>
        <text x="318" y="20" fill="#94a3b8" font-size="12" font-family="IBM Plex Mono" text-anchor="middle">T3</text>
        <text x="406" y="20" fill="#f59e0b" font-size="12" font-family="IBM Plex Mono" text-anchor="middle">Tw</text>
        <text x="493" y="20" fill="#94a3b8" font-size="12" font-family="IBM Plex Mono" text-anchor="middle">T4</text>

        <!-- Vertical dividers -->
        <line x1="187" y1="25" x2="187" y2="310" stroke="#1e2d44" stroke-width="1" stroke-dasharray="2,3"/>
        <line x1="275" y1="25" x2="275" y2="310" stroke="#1e2d44" stroke-width="1" stroke-dasharray="2,3"/>
        <line x1="362" y1="25" x2="362" y2="310" stroke="#1e2d44" stroke-width="1" stroke-dasharray="2,3"/>
        <line x1="450" y1="25" x2="450" y2="310" stroke="#f59e0b" stroke-width="0.5" stroke-dasharray="2,3"/>
        <line x1="537" y1="25" x2="537" y2="310" stroke="#1e2d44" stroke-width="1" stroke-dasharray="2,3"/>

        <!-- Signal labels -->
        <text x="90" y="55" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">CLK</text>
        <text x="90" y="105" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">ALE</text>
        <text x="90" y="150" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">AD0-7</text>
        <text x="90" y="195" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">A16-19</text>
        <text x="90" y="240" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">RD'</text>
        <text x="90" y="285" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">DEN'</text>

        <!-- CLK waveform -->
        <polyline points="100,60 100,40 129,40 129,60 158,60 158,40 187,40 187,60 216,60 216,40 245,40 245,60 275,60 275,40 304,40 304,60 333,60 333,40 362,40 362,60 391,60 391,40 420,40 420,60 450,60 450,40 479,40 479,60 508,60 508,40 537,40 537,60 566,60" fill="none" stroke="#3b82f6" stroke-width="1.5"/>

        <!-- ALE pulse -->
        <polyline points="100,110 120,110 120,90 165,90 165,110 537,110" fill="none" stroke="#22c55e" stroke-width="1.5"/>

        <!-- AD0-7: Address then Data -->
        <rect x="110" y="135" width="77" height="22" rx="3" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="1"/>
        <text x="148" y="150" fill="#3b82f6" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">A0-A7</text>
        <rect x="210" y="135" width="30" height="22" rx="3" fill="rgba(148,163,184,0.1)" stroke="#475569" stroke-width="1"/>
        <rect x="300" y="135" width="237" height="22" rx="3" fill="rgba(6,182,212,0.15)" stroke="#06b6d4" stroke-width="1"/>
        <text x="418" y="150" fill="#06b6d4" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">D0-D7 (Data)</text>

        <!-- A16-19/S3-S6 -->
        <rect x="110" y="180" width="77" height="22" rx="3" fill="rgba(139,92,246,0.15)" stroke="#8b5cf6" stroke-width="1"/>
        <text x="148" y="195" fill="#8b5cf6" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">A16-19</text>
        <rect x="210" y="180" width="327" height="22" rx="3" fill="rgba(148,163,184,0.1)" stroke="#475569" stroke-width="1"/>
        <text x="373" y="195" fill="#475569" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">S3-S6 (Status)</text>

        <!-- RD' (active low during T2-Tw) -->
        <polyline points="100,230 231,230 231,245 450,245 450,230 537,230" fill="none" stroke="#ef4444" stroke-width="1.5"/>
        <text x="340" y="258" fill="#ef4444" font-size="9" font-family="IBM Plex Mono" text-anchor="middle">Active (Read)</text>

        <!-- DEN' -->
        <polyline points="100,275 210,275 210,290 470,290 470,275 537,275" fill="none" stroke="#f59e0b" stroke-width="1.5"/>
        <text x="340" y="303" fill="#f59e0b" font-size="9" font-family="IBM Plex Mono" text-anchor="middle">Active (Buffer On)</text>
      </svg>
    </div>

    <div class="card" style="border-color:rgba(251,191,36,0.3); background:linear-gradient(135deg, var(--surface), rgba(251,191,36,0.04));">
      <h3><span class="icon amber">‚òÖ</span> Wait States: What They Are and How to Calculate Them</h3>
      <p>The CPU expects memory to respond within a fixed window (roughly <strong>3 T-states</strong> from address out to data needed). But what if the memory chip is too slow?</p>

      <div class="kv-grid" style="margin-top:12px;">
        <div class="kv">
          <div class="kv-label">The Problem</div>
          <div class="kv-value">The CPU puts an address on the bus at the start of T1. By mid-T3, it samples the data bus expecting valid data. The total time the memory has = about 3 T-states, minus delays through the latch (74LS373) and buffer (74LS245) and the CPU's own data setup time. If the memory chip can't respond in that window, the data won't be valid when the CPU reads it ‚Üí wrong data.</div>
        </div>
        <div class="kv">
          <div class="kv-label">The Solution: Wait States (Tw)</div>
          <div class="kv-value">The CPU inserts extra T-states (called <strong>Tw</strong>) between T3 and T4. Each wait state adds exactly <strong>1 T-state</strong> of extra time. During Tw, the CPU just... waits. It keeps checking the <code>READY</code> pin ‚Äî when READY goes high, the CPU exits the wait state and proceeds to T4 to read the data. The 8284 synchronizes the READY signal so it aligns with the clock edge.</div>
        </div>
        <div class="kv">
          <div class="kv-label">The 3-Step Calculation</div>
          <div class="kv-value">
            <strong>Step 1:</strong> Calculate available time (with 0 wait states):<br>
            <code>t_available = (number of T-states from addr valid to data sample) √ó T_state ‚àí t_latch ‚àí t_buffer ‚àí t_setup</code><br>
            For the 8088: typically ~3 T-states √ó T_state, minus delays. (Exact value depends on the specific timing parameters from the datasheet.)<br><br>
            <strong>Step 2:</strong> Compare with memory access time:<br>
            If <code>t_memory ‚â§ t_available</code> ‚Üí <strong>0 wait states needed</strong>. Memory is fast enough.<br>
            If <code>t_memory > t_available</code> ‚Üí need wait states.<br><br>
            <strong>Step 3:</strong> Calculate how many:<br>
            <code>n_wait = ‚åà(t_memory ‚àí t_available) / T_state‚åâ</code><br>
            (That's ceiling ‚Äî always round UP. You can't add half a wait state.)<br>
            Each wait state gives you an extra T_state of time.
          </div>
        </div>
        <div class="kv">
          <div class="kv-label">Quick Example</div>
          <div class="kv-value">
            8088 at 5 MHz ‚Üí T_state = 200 ns ‚Üí available time (after delays) = 440 ns.<br>
            Memory A = 350 ns ‚Üí 350 < 440 ‚Üí <strong>0 wait states</strong>. ‚úì<br>
            Memory B = 500 ns ‚Üí 500 > 440 ‚Üí deficit = 60 ns ‚Üí 60/200 = 0.3 ‚Üí ‚åà0.3‚åâ = <strong>1 wait state</strong>.<br>
            With 1 wait state: new available = 440 + 200 = 640 ns. 500 < 640 ‚úì
          </div>
        </div>
      </div>

      <div class="callout tip" style="margin-top:12px;">
        <strong>Bus cycle duration formula:</strong> <code>Bus cycle = (4 + n_wait) √ó T_state</code>. With 0 wait states at 5 MHz: 4 √ó 200 = 800 ns. With 1 wait state: 5 √ó 200 = 1000 ns. Every wait state makes the system slower ‚Äî that's why fast memory matters.
      </div>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> Read Timing Parameters</h3>
      <ul>
        <li><strong>Address Access Time</strong> ‚Äî max time memory has to decode address and place data on bus (measured from address valid to data valid)</li>
        <li><strong>Read-to-Data Valid</strong> ‚Äî max time after <code>RD'</code> activates until valid data appears</li>
        <li><strong>Command Enable to Data Valid</strong> ‚Äî max time after <code>DEN'</code> activates until valid data</li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Write Timing Parameters</h3>
      <ul>
        <li><strong>Write Pulse Width</strong> ‚Äî duration of <code>WR'</code> signal needed by memory</li>
        <li><strong>Data Setup Time</strong> ‚Äî minimum time valid data is held <em>before</em> <code>WR'</code> deactivates</li>
        <li><strong>Data Hold Time</strong> ‚Äî minimum time data is valid <em>after</em> <code>WR'</code> deactivates</li>
      </ul>
    </div>

    <div class="callout warn">
      <strong>Key exam point (from lecture):</strong> "Data setup time is timed against the <em>deactivation</em> of the write signal, not activation. Don't forget to include gate propagation delay!"
    </div>
  </div>

  <!-- 8086 Data Bus -->
  <div class="section" id="8086-databus">
    <span class="section-num">01.5 ¬∑ 16-BIT DATA BUS</span>
    <h2>8086 Memory Access & BHE'</h2>

    <p>The 8086 has a 16-bit external data bus. It accesses 16-bit words using <strong>two adjacent 8-bit memory banks</strong> ‚Äî an even bank (D0‚ÄìD7) and an odd bank (D8‚ÄìD15). The <code>BHE'</code> and <code>A0</code> pins determine which bank is accessed.</p>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> Memory Access Encoding</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>BHE'</th><th>A0</th><th>Action</th><th>Bus Lines</th></tr></thead>
          <tbody>
            <tr><td>0</td><td>0</td><td><strong>16-bit word access</strong> (even aligned)</td><td>D0‚ÄìD15</td></tr>
            <tr><td>0</td><td>1</td><td>Odd byte access (high bank)</td><td>D8‚ÄìD15</td></tr>
            <tr><td>1</td><td>0</td><td>Even byte access (low bank)</td><td>D0‚ÄìD7</td></tr>
            <tr><td>1</td><td>1</td><td>No action</td><td>‚Äî</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> Performance Impact: Alignment</h3>
      <ul>
        <li><strong>8-bit fetches:</strong> 1 machine cycle (same as 8088, regardless of even/odd address)</li>
        <li><strong>16-bit from EVEN address:</strong> <mark>1 machine cycle</mark> (vs. 2 on 8088)</li>
        <li><strong>16-bit from ODD address:</strong> <mark>2 machine cycles!</mark> ‚Äî fetches odd byte first, then even byte next cycle</li>
      </ul>
      <div class="callout warn">
        <strong>Optimization rule:</strong> <em>Never</em> fetch 16-bit operands from ODD addresses ‚Äî it requires TWO machine cycles. Use the <code>PARA</code> directive for paragraph alignment. This rule extends to 32-bit (4-byte aligned) and 64-bit (8-byte aligned) CPUs.
      </div>
    </div>

    <div class="card">
      <div class="callout">
        <strong>Jan 15 lecture walkthrough:</strong> Sir Clem demonstrated three instructions to show code compatibility:
        <br><code>MOV AH, [2000h]</code> ‚Üí 8-bit from even addr ‚Üí 1 cycle on both CPUs
        <br><code>MOV AL, [2000h]</code> ‚Üí 8-bit from even addr ‚Üí 1 cycle on both CPUs
        <br><code>MOV AX, [2000h]</code> ‚Üí 16-bit from even addr ‚Üí 1 cycle on 8086, <strong>2 cycles on 8088</strong>
        <br><code>MOV AX, [2005h]</code> ‚Üí 16-bit from <strong>odd</strong> addr ‚Üí <strong>2 cycles on BOTH</strong> (8086 must split across banks)
      </div>

      <!-- 8086 Memory Bank Layout SVG -->
      <div style="margin:20px 0;">
        <svg viewBox="0 0 650 280" style="width:100%; max-width:650px; margin:0 auto; display:block;">
          <style>
            .bank-label { fill: #e2e8f0; font-size: 13px; font-family: 'Space Grotesk', sans-serif; font-weight: 600; }
            .addr-text { fill: #94a3b8; font-size: 10px; font-family: 'IBM Plex Mono', monospace; }
            .data-text { fill: #e2e8f0; font-size: 10px; font-family: 'IBM Plex Mono', monospace; }
            .bank-cell { stroke: rgba(255,255,255,0.1); stroke-width: 1; }
            .highlight-even { fill: rgba(59,130,246,0.2); stroke: #3b82f6; stroke-width: 1.5; }
            .highlight-odd { fill: rgba(139,92,246,0.2); stroke: #8b5cf6; stroke-width: 1.5; }
            .highlight-both { fill: rgba(6,182,212,0.15); stroke: #06b6d4; stroke-width: 1.5; }
            .arrow { stroke: #f59e0b; stroke-width: 1.5; fill: none; marker-end: url(#arrowhead); }
          </style>
          <defs><marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#f59e0b"/></marker></defs>

          <!-- Even Bank (A0=0) -->
          <text x="95" y="20" class="bank-label" text-anchor="middle">Even Bank (A0=0)</text>
          <text x="95" y="34" class="addr-text" text-anchor="middle">D0‚ÄìD7</text>
          <rect x="30" y="42" width="130" height="28" class="bank-cell" fill="rgba(59,130,246,0.08)"/>
          <text x="40" y="60" class="addr-text">00000h</text><text x="120" y="60" class="data-text">byte</text>
          <rect x="30" y="70" width="130" height="28" class="bank-cell" fill="rgba(59,130,246,0.08)"/>
          <text x="40" y="88" class="addr-text">00002h</text><text x="120" y="88" class="data-text">byte</text>
          <rect x="30" y="98" width="130" height="28" class="bank-cell" fill="rgba(59,130,246,0.08)"/>
          <text x="40" y="116" class="addr-text">00004h</text><text x="120" y="116" class="data-text">byte</text>
          <rect x="30" y="126" width="130" height="28" class="bank-cell highlight-even"/>
          <text x="40" y="144" class="addr-text">02000h</text><text x="110" y="144" class="data-text" style="fill:#3b82f6;">byte‚ÇÄ</text>
          <rect x="30" y="154" width="130" height="28" class="bank-cell" fill="rgba(59,130,246,0.08)"/>
          <text x="40" y="172" class="addr-text">02002h</text><text x="120" y="172" class="data-text">byte</text>
          <rect x="30" y="182" width="130" height="28" class="bank-cell" fill="rgba(59,130,246,0.08)"/>
          <text x="40" y="200" class="addr-text">02004h</text><text x="120" y="200" class="data-text">byte</text>
          <rect x="30" y="210" width="130" height="28" class="bank-cell highlight-even"/>
          <text x="40" y="228" class="addr-text">02006h</text><text x="110" y="228" class="data-text" style="fill:#3b82f6;">byte‚ÇÜ</text>

          <!-- Odd Bank (BHE'=0) -->
          <text x="295" y="20" class="bank-label" text-anchor="middle">Odd Bank (BHE'=0)</text>
          <text x="295" y="34" class="addr-text" text-anchor="middle">D8‚ÄìD15</text>
          <rect x="230" y="42" width="130" height="28" class="bank-cell" fill="rgba(139,92,246,0.08)"/>
          <text x="240" y="60" class="addr-text">00001h</text><text x="320" y="60" class="data-text">byte</text>
          <rect x="230" y="70" width="130" height="28" class="bank-cell" fill="rgba(139,92,246,0.08)"/>
          <text x="240" y="88" class="addr-text">00003h</text><text x="320" y="88" class="data-text">byte</text>
          <rect x="230" y="98" width="130" height="28" class="bank-cell" fill="rgba(139,92,246,0.08)"/>
          <text x="240" y="116" class="addr-text">00005h</text><text x="320" y="116" class="data-text">byte</text>
          <rect x="230" y="126" width="130" height="28" class="bank-cell highlight-odd"/>
          <text x="240" y="144" class="addr-text">02001h</text><text x="310" y="144" class="data-text" style="fill:#8b5cf6;">byte‚ÇÅ</text>
          <rect x="230" y="154" width="130" height="28" class="bank-cell" fill="rgba(139,92,246,0.08)"/>
          <text x="240" y="172" class="addr-text">02003h</text><text x="320" y="172" class="data-text">byte</text>
          <rect x="230" y="182" width="130" height="28" class="bank-cell highlight-odd"/>
          <text x="240" y="200" class="addr-text">02005h</text><text x="310" y="200" class="data-text" style="fill:#8b5cf6;">byte‚ÇÖ</text>
          <rect x="230" y="210" width="130" height="28" class="bank-cell" fill="rgba(139,92,246,0.08)"/>
          <text x="240" y="228" class="addr-text">02007h</text><text x="320" y="228" class="data-text">byte</text>

          <!-- Annotations -->
          <text x="440" y="60" class="bank-label" style="font-size:11px;">MOV AX, [2000h]</text>
          <text x="440" y="78" class="addr-text" style="fill:#06b6d4;">Both banks ‚Üí 1 cycle ‚úì</text>
          <path d="M430,68 L365,140" class="arrow"/>
          <path d="M430,68 L165,140" class="arrow"/>

          <text x="440" y="140" class="bank-label" style="font-size:11px;">MOV AX, [2005h]</text>
          <text x="440" y="158" class="addr-text" style="fill:#ef4444;">Split ‚Üí 2 cycles ‚úó</text>
          <text x="440" y="172" class="addr-text" style="fill:#ef4444;">Cycle 1: odd bank (2005h)</text>
          <text x="440" y="186" class="addr-text" style="fill:#ef4444;">Cycle 2: even bank (2006h)</text>
          <path d="M430,155 L365,197" class="arrow" style="stroke:#ef4444;"/>
          <path d="M430,170 L165,225" class="arrow" style="stroke:#ef4444;"/>

          <!-- Legend -->
          <text x="30" y="268" class="addr-text">Note: Adjacent addresses in same row = same physical memory line. 16-bit access activates both banks simultaneously.</text>
        </svg>
      </div>

      <h3><span class="icon green">‚óÜ</span> 8086 Memory Interface Design</h3>
      <p>Two 2K√ó8 SRAM chips are used ‚Äî one for each bank:</p>
      <ul>
        <li><strong>Even bank:</strong> CS connected to <code>A0</code> (inverted) + address decoder, data on D0‚ÄìD7</li>
        <li><strong>Odd bank:</strong> CS connected to <code>BHE'</code> + address decoder, data on D8‚ÄìD15</li>
        <li>Address lines <code>A1‚ÄìA11</code> go to both chips' address inputs</li>
        <li><code>A12‚ÄìA19</code> go to the address decoder for chip select</li>
      </ul>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- MODULE 2: DRAM Technology      -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="section" id="dram-tech">
    <span class="section-num">02 ¬∑ DRAM TECHNOLOGY</span>
    <h2>SRAM vs DRAM</h2>

    <div class="compare">
      <div class="compare-col">
        <h4>SRAM</h4>
        <ul>
          <li>~6 transistors per cell (latch mechanism)</li>
          <li>No refresh needed ‚Äî static retention</li>
          <li>Faster access time</li>
          <li>Lower density, higher cost per bit</li>
          <li><strong>Use:</strong> cache, microcontroller RAM</li>
        </ul>
      </div>
      <div class="compare-col">
        <h4>DRAM</h4>
        <ul>
          <li>1 transistor + 1 capacitor per cell</li>
          <li><mark>Requires constant refresh</mark></li>
          <li>Slower but much higher density</li>
          <li>Lower cost per bit</li>
          <li><strong>Use:</strong> main memory in PCs</li>
        </ul>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> DRAM Internal Architecture</h3>
      <p>DRAM is internally organized as a 2D matrix of rows and columns. Address lines are <strong>multiplexed</strong> ‚Äî the same pins carry row address first, then column address.</p>
      <ul>
        <li><strong>Row Address Latch + Decoder</strong> ‚Äî activated by <code>RAS'</code> (Row Address Strobe)</li>
        <li><strong>Column Address Latch + Decoder</strong> ‚Äî activated by <code>CAS'</code> (Column Address Strobe)</li>
        <li><strong>Sense Amplifiers</strong> ‚Äî detect tiny charge differences; also refresh the row during read</li>
        <li><strong>Data I/O Buffer</strong> ‚Äî connects to external data bus</li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> DRAM Access Sequence (Read)</h3>
      <div class="flow">
        <div class="flow-step">‚ë† Row addr on bus</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë° RAS' goes low</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë¢ Row decoded, cells accessed</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë£ Sense amps restore row</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë§ Col addr on bus</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë• CAS' goes low</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë¶ Data output valid</div>
      </div>
    </div>
  </div>


    <div class="card">
      <h3><span class="icon red">‚óÜ</span> SRAM: 6 Transistors Per Bit (from Jan 15 lecture)</h3>
      <p>An SRAM cell is a <strong>cross-coupled flip-flop</strong>: 2 transistors for the latch + 4 transistors replacing resistors (resistors are hard to fabricate on silicon). That's <strong>6 transistors per bit</strong>. One byte = 48 transistors. A 64KB SRAM = 64K √ó 8 √ó 6 = ~3.1 million transistors. This is why SRAMs are small-capacity but very fast (no charge/discharge delay).</p>
      <p>DRAM uses <strong>1 transistor + 1 capacitor per bit</strong>. The transistor acts as an access gate; the capacitor stores the charge (logic 1/0). Much higher density, but the capacitor leaks ‚Üí requires periodic refresh.</p>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Write Timing: Early Write vs. Standard Write</h3>
      <p>From the Jan 15 lecture, there are two write modes:</p>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">Early Write</div>
          <div class="kv-value">WE' goes active <strong>before</strong> CAS' completes. The chip knows immediately it's a write. OE' is <strong>don't care</strong> ‚Äî no risk of accidental read conflict. Simpler circuit design.</div>
        </div>
        <div class="kv">
          <div class="kv-label">Standard (Late) Write</div>
          <div class="kv-value">WE' goes active <strong>after</strong> CAS'. The chip initially doesn't know if it's read or write. You <strong>must hold OE' high</strong> to prevent the chip from outputting data (which would cause bus conflict). More flexible but requires careful OE' control.</div>
        </div>
      </div>
      <p style="margin-top:8px;">Both have the same write cycle time (tWC). The choice depends on your controller design ‚Äî if you can assert WE' early, the circuit is simpler.</p>
    </div>

  <!-- DRAM Timing -->
  <div class="section" id="dram-timing">
    <span class="section-num">02.1 ¬∑ DRAM TIMING</span>
    <h2>DRAM Timing Diagrams</h2>

    <!-- DRAM Read Timing -->
    <div class="timing-diagram">
      <svg viewBox="0 0 700 280" xmlns="http://www.w3.org/2000/svg">
        <rect width="700" height="280" fill="#111827" rx="8"/>
        <text x="350" y="18" fill="#94a3b8" font-size="12" font-family="IBM Plex Mono" text-anchor="middle" font-weight="600">DRAM Read Cycle Timing</text>

        <!-- Labels -->
        <text x="55" y="55" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">RAS'</text>
        <text x="55" y="100" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">CAS'</text>
        <text x="55" y="145" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">Addr</text>
        <text x="55" y="190" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">W'</text>
        <text x="55" y="235" fill="#94a3b8" font-size="11" font-family="IBM Plex Mono" text-anchor="end">DQ</text>

        <!-- tRC bracket -->
        <line x1="100" y1="30" x2="600" y2="30" stroke="#3b82f6" stroke-width="1"/>
        <line x1="100" y1="27" x2="100" y2="33" stroke="#3b82f6" stroke-width="1"/>
        <line x1="600" y1="27" x2="600" y2="33" stroke="#3b82f6" stroke-width="1"/>
        <text x="350" y="28" fill="#3b82f6" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">tRC (Read Cycle Time)</text>

        <!-- RAS' -->
        <polyline points="70,45 120,45 120,60 480,60 480,45 600,45" fill="none" stroke="#ef4444" stroke-width="1.5"/>

        <!-- CAS' -->
        <polyline points="70,90 220,90 220,105 430,105 430,90 600,90" fill="none" stroke="#f59e0b" stroke-width="1.5"/>

        <!-- Address: Row then Column -->
        <rect x="90" y="130" width="120" height="22" rx="3" fill="rgba(139,92,246,0.15)" stroke="#8b5cf6" stroke-width="1"/>
        <text x="150" y="145" fill="#8b5cf6" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">Row</text>
        <rect x="220" y="130" width="130" height="22" rx="3" fill="rgba(6,182,212,0.15)" stroke="#06b6d4" stroke-width="1"/>
        <text x="285" y="145" fill="#06b6d4" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">Column</text>

        <!-- W' (high = read) -->
        <polyline points="70,180 600,180" fill="none" stroke="#22c55e" stroke-width="1.5"/>
        <text x="340" y="178" fill="#22c55e" font-size="9" font-family="IBM Plex Mono" text-anchor="middle">HIGH (Read mode)</text>

        <!-- DQ: Hi-Z then valid data -->
        <rect x="70" y="222" width="300" height="22" rx="3" fill="rgba(148,163,184,0.05)" stroke="#334155" stroke-width="1"/>
        <text x="220" y="237" fill="#475569" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">Hi-Z</text>
        <rect x="380" y="222" width="120" height="22" rx="3" fill="rgba(34,197,94,0.15)" stroke="#22c55e" stroke-width="1"/>
        <text x="440" y="237" fill="#22c55e" font-size="10" font-family="IBM Plex Mono" text-anchor="middle">Valid Data</text>

        <!-- Timing annotations -->
        <line x1="120" y1="65" x2="220" y2="65" stroke="#94a3b8" stroke-width="0.5" stroke-dasharray="2,2"/>
        <text x="170" y="75" fill="#94a3b8" font-size="8" font-family="IBM Plex Mono" text-anchor="middle">tRCD</text>
      </svg>
    </div>

    <div class="card">

      <!-- DRAM Read Cycle SVG Timing Diagram -->
      <div style="margin:20px 0;">
        <svg viewBox="0 0 700 300" style="width:100%; max-width:700px; margin:0 auto; display:block;">
          <style>
            .sig-label { fill: #94a3b8; font-size: 11px; font-family: 'IBM Plex Mono', monospace; }
            .sig-line { stroke-width: 2; fill: none; }
            .dim-dash { stroke: rgba(255,255,255,0.12); stroke-width: 0.5; stroke-dasharray: 3; }
            .time-label { fill: #f59e0b; font-size: 9px; font-family: 'IBM Plex Mono', monospace; }
            .time-arrow { stroke: #f59e0b; stroke-width: 1; fill: none; marker-end: url(#arr2); marker-start: url(#arr2r); }
          </style>
          <defs>
            <marker id="arr2" markerWidth="6" markerHeight="4" refX="6" refY="2" orient="auto"><polygon points="0 0, 6 2, 0 4" fill="#f59e0b"/></marker>
            <marker id="arr2r" markerWidth="6" markerHeight="4" refX="0" refY="2" orient="auto"><polygon points="6 0, 0 2, 6 4" fill="#f59e0b"/></marker>
          </defs>

          <!-- Address lines -->
          <text x="10" y="35" class="sig-label">ADDR</text>
          <rect x="80" y="20" width="160" height="24" fill="rgba(59,130,246,0.15)" stroke="#3b82f6" stroke-width="1" rx="2"/>
          <text x="130" y="36" class="sig-label" style="fill:#3b82f6;">Row Addr</text>
          <rect x="280" y="20" width="160" height="24" fill="rgba(139,92,246,0.15)" stroke="#8b5cf6" stroke-width="1" rx="2"/>
          <text x="325" y="36" class="sig-label" style="fill:#8b5cf6;">Col Addr</text>

          <!-- RAS' signal -->
          <text x="10" y="85" class="sig-label">RAS'</text>
          <polyline class="sig-line" style="stroke:#22c55e;" points="80,70 160,70 165,95 500,95 505,70 680,70"/>

          <!-- CAS' signal -->
          <text x="10" y="145" class="sig-label">CAS'</text>
          <polyline class="sig-line" style="stroke:#06b6d4;" points="80,130 280,130 285,155 460,155 465,130 680,130"/>

          <!-- OE' signal -->
          <text x="10" y="195" class="sig-label">OE'</text>
          <polyline class="sig-line" style="stroke:#f59e0b;" points="80,180 200,180 205,205 470,205 475,180 680,180"/>

          <!-- Data Out -->
          <text x="10" y="255" class="sig-label">DOUT</text>
          <polyline class="sig-line" style="stroke:#e2e8f0;" points="80,250 380,250"/>
          <rect x="380" y="237" width="90" height="24" fill="rgba(34,197,94,0.15)" stroke="#22c55e" stroke-width="1.5" rx="2"/>
          <text x="400" y="253" class="sig-label" style="fill:#22c55e;">Valid</text>
          <polyline class="sig-line" style="stroke:#e2e8f0;" points="470,250 680,250"/>

          <!-- Timing annotations -->
          <line x1="165" y1="100" x2="165" y2="270" class="dim-dash"/>
          <line x1="285" y1="160" x2="285" y2="270" class="dim-dash"/>
          <line x1="380" y1="237" x2="380" y2="280" class="dim-dash"/>
          <line x1="505" y1="100" x2="505" y2="280" class="dim-dash"/>

          <!-- tRCD -->
          <line x1="165" y1="115" x2="285" y2="115" class="time-arrow"/>
          <text x="200" y="112" class="time-label">tRCD</text>

          <!-- tRAC -->
          <line x1="165" y1="265" x2="380" y2="265" class="time-arrow"/>
          <text x="245" y="280" class="time-label">tRAC (row access time)</text>

          <!-- tCAC -->
          <line x1="285" y1="168" x2="380" y2="168" class="time-arrow"/>
          <text x="310" y="165" class="time-label">tCAC</text>

          <!-- tRC -->
          <line x1="80" y1="290" x2="505" y2="290" class="time-arrow" style="stroke:#ef4444;"/>
          <text x="250" y="298" class="time-label" style="fill:#ef4444;">tRC (full read cycle)</text>
        </svg>
      </div>

      <h3><span class="icon blue">‚óÜ</span> Key DRAM Timing Parameters</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Parameter</th><th>Symbol</th><th>Description</th></tr></thead>
          <tbody>
            <tr><td>Read Cycle Time</td><td><code>tRC</code></td><td>Min time between successive read operations</td></tr>
            <tr><td>Write Cycle Time</td><td><code>tWC</code></td><td>Min time between successive write operations</td></tr>
            <tr><td>RAS Pulse Width</td><td><code>tRAS</code></td><td>Min time RAS' must be held low</td></tr>
            <tr><td>CAS Pulse Width</td><td><code>tCAS</code></td><td>Min time CAS' must be held low</td></tr>
            <tr><td>RAS-to-CAS Delay</td><td><code>tRCD</code></td><td>Min time between RAS' and CAS' activation</td></tr>
            <tr><td>Row Address Setup</td><td><code>tASR</code></td><td>Time row address must be valid before RAS'</td></tr>
            <tr><td>Row Address Hold</td><td><code>tRAH</code></td><td>Time row address must be held after RAS'</td></tr>
            <tr><td>CAS Access Time</td><td><code>tCAC</code></td><td>Time from CAS' to valid data output</td></tr>
            <tr><td>RAS Precharge</td><td><code>tRP</code></td><td>Min time RAS' must be high between accesses</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Write Timing Modes</h3>
      <p>DRAM supports two write timing modes:</p>
      <ul>
        <li><strong>Early Write:</strong> <code>W'</code> goes low <em>before</em> <code>CAS'</code> ‚Äî data must be valid when CAS' falls</li>
        <li><strong>Late Write (Read-Modify-Write):</strong> <code>W'</code> goes low <em>after</em> <code>CAS'</code> ‚Äî allows read-then-write in one cycle</li>
      </ul>
    </div>
  </div>

  <!-- DRAM Refresh -->
  <div class="section" id="dram-refresh">
    <span class="section-num">02.2 ¬∑ DRAM REFRESH</span>
    <h2>DRAM Refresh Mechanisms</h2>

    <p>Since DRAM stores data as charge on capacitors, it <strong>leaks</strong> over time. Every row must be refreshed within the specified retention time (typically 2‚Äì64 ms for all rows). Only the <strong>row address</strong> is needed to refresh ‚Äî the entire row is restored when sense amplifiers fire.</p>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> Refresh Modes</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Mode</th><th>How It Works</th><th>Pros / Cons</th></tr></thead>
          <tbody>
            <tr>
              <td><strong>RAS-Only Refresh</strong></td>
              <td>External circuit provides row address, pulses <code>RAS'</code> only (no <code>CAS'</code>)</td>
              <td>Simple; requires external row counter</td>
            </tr>
            <tr>
              <td><strong>CAS-Before-RAS (CBR)</strong></td>
              <td><code>CAS'</code> goes low <em>before</em> <code>RAS'</code> ‚Äî DRAM uses internal counter for row address</td>
              <td>No external counter needed; self-refreshing</td>
            </tr>
            <tr>
              <td><strong>Hidden Refresh</strong></td>
              <td>Refresh occurs while <code>CAS'</code> remains low after a normal read ‚Äî different row refreshed</td>
              <td>Hides refresh latency; complex timing</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> Refresh Strategies</h3>
      <ul>
        <li><strong>Burst Refresh:</strong> All rows refreshed consecutively in one burst ‚Äî CPU is locked out for the entire refresh period</li>
        <li><strong>Distributed Refresh:</strong> One row refreshed at a time, spread over the retention period ‚Äî less CPU disruption</li>
        <li><strong>Hidden Refresh:</strong> Row refreshed during an active memory access cycle</li>
      </ul>
      <div class="callout">
        <strong>From lecture:</strong> "If the CPU hangs during software-based refresh, you lose your DRAM contents. Hardware-based refresh (e.g., using a DMA controller or dedicated DRAM controller) is more reliable."
      </div>
    </div>
  </div>

  <!-- DRAM Page Mode -->
  <div class="section" id="dram-page">
    <span class="section-num">02.3 ¬∑ PAGE MODE</span>
    <h2>DRAM Page Mode Access</h2>

    <p>Page mode takes advantage of the fact that once a row is activated, multiple columns within that row can be accessed <strong>without re-asserting RAS'</strong>. This significantly speeds up sequential access.</p>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> How Page Mode Works</h3>
      <ul>
        <li><code>RAS'</code> is asserted once ‚Äî row is activated and remains open</li>
        <li><code>CAS'</code> is toggled for each column access within the same row</li>
        <li>Subsequent accesses only take <code>tCAS</code> time (much shorter than full <code>tRC</code>)</li>
        <li>The "page" is the entire row of the DRAM array</li>
      </ul>
      <p>This is available for both read and write operations.</p>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- MODULE 3: Interrupts           -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="section" id="interrupts">
    <span class="section-num">03 ¬∑ INTERRUPT SYSTEM</span>
    <h2>8088/8086 Interrupt System</h2>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> Vector-Type Interrupt System</h3>
      <ul>
        <li>The 8086/8088 uses a <strong>vectored interrupt</strong> system with 256 interrupt types (0‚Äì255)</li>
        <li>The <strong>Interrupt Vector Table (IVT)</strong> occupies the first <strong>1 KB</strong> of memory (addresses 00000h‚Äì003FFh)</li>
        <li>Each vector = 4 bytes: 2 bytes IP (low word) + 2 bytes CS (high word)</li>
        <li>Vector table address = <code>type_number √ó 4</code></li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> Interrupt Sequence (Internal)</h3>
      <div class="flow">
        <div class="flow-step">‚ë† Type# √ó 4 = vector addr</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë° Push FLAGS, CS, IP</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë¢ Read ISR address from IVT</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë£ Load CS:IP ‚Üí branch to ISR</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë§ IRET: pop IP, CS, FLAGS</div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Interrupt Types</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Type</th><th>Vector</th><th>Category</th><th>Description</th></tr></thead>
          <tbody>
            <tr><td>0</td><td>00h</td><td>Internal</td><td>Divide Error</td></tr>
            <tr><td>1</td><td>04h</td><td>Internal</td><td>Single Step (TF=1)</td></tr>
            <tr><td>2</td><td>08h</td><td>Hardware</td><td>NMI (Non-Maskable)</td></tr>
            <tr><td>3</td><td>0Ch</td><td>Software</td><td>Breakpoint (INT 3)</td></tr>
            <tr><td>4</td><td>10h</td><td>Internal</td><td>Overflow (INTO)</td></tr>
            <tr><td>5‚Äì31</td><td>14h‚Äì7Fh</td><td>‚Äî</td><td>Reserved by Intel</td></tr>
            <tr><td>32‚Äì255</td><td>80h‚Äì3FFh</td><td>‚Äî</td><td>User-available</td></tr>
          </tbody>
        </table>
      </div>
      <p><strong>Priority:</strong> Software interrupts > Hardware (INTR) interrupts. NMI is non-maskable (cannot be disabled by IF flag).</p>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> External Hardware Interrupt Sequence</h3>
      <div class="flow">
        <div class="flow-step">‚ë† Device asserts INTR</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë° CPU sends 1st INTA'</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë¢ CPU sends 2nd INTA'</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë£ Device places type# on D0‚ÄìD7</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë§ CPU vectors to ISR</div>
      </div>
      <p style="margin-top:12px;">The LOCK signal is asserted between the two INTA' pulses to prevent other bus masters from interfering.</p>
    </div>
  </div>

  <!-- 8259 PIC -->
  <div class="section" id="8259">
    <span class="section-num">03.1 ¬∑ 8259 PIC</span>
    <h2>8259 Programmable Interrupt Controller</h2>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> 8259 Features</h3>
      <ul>
        <li>Manages <strong>8 levels</strong> of interrupts (IR0‚ÄìIR7)</li>
        <li>Can be <strong>cascaded</strong> (master/slave) for up to <strong>64 interrupt levels</strong></li>
        <li>Programmable priority modes (fixed, rotating, specific)</li>
        <li>Supports 8080, 8085, and 8086/88</li>
        <li>Provides the interrupt type number on the data bus during INTA' cycle</li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> 8259 Key Pins</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Pin</th><th>Function</th></tr></thead>
          <tbody>
            <tr><td><code>IR0‚ÄìIR7</code></td><td>Interrupt request inputs from peripherals</td></tr>
            <tr><td><code>INT</code></td><td>Output to CPU's INTR pin</td></tr>
            <tr><td><code>INTA'</code></td><td>Input from CPU's INTA' ‚Äî triggers type# output</td></tr>
            <tr><td><code>D0‚ÄìD7</code></td><td>Bidirectional data bus (programming & type# output)</td></tr>
            <tr><td><code>CS', RD', WR', A0</code></td><td>Standard I/O interface for programming</td></tr>
            <tr><td><code>CAS0‚ÄìCAS2</code></td><td>Cascade bus for master/slave configuration</td></tr>
            <tr><td><code>SP'/EN'</code></td><td>Slave Program / Buffer Enable</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> Cascading 8259s</h3>
      <p>In a cascaded configuration, the <strong>master</strong> 8259's <code>SP'/EN'</code> is tied to VCC, and <strong>slave</strong> 8259s have it grounded. The master's CAS0‚ÄìCAS2 lines connect to all slaves. When a slave's interrupt is acknowledged, the master outputs the slave's ID on the cascade bus, and the slave then provides the type number.</p>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- MODULE 4: DMA                  -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="section" id="dma">
    <span class="section-num">04 ¬∑ DIRECT MEMORY ACCESS</span>
    <h2>8237 DMA Controller</h2>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> Why DMA?</h3>
      <p>CPU-based data movement (e.g., MOV in a loop) is:</p>
      <ul>
        <li><strong>Slow</strong> ‚Äî each byte requires multiple instruction cycles (fetch, decode, execute, loop)</li>
        <li><strong>Ties up the CPU</strong> ‚Äî can't do anything else during the transfer</li>
        <li><strong>Inefficient</strong> ‚Äî all that processing power just for data movement</li>
      </ul>
      <p>A DMAC is a <strong>state-machine</strong> (no code to execute), takes over the bus, and can activate MEM and I/O control lines <strong>simultaneously</strong>.</p>
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> DMA Transfer Types</h3>
      <ul>
        <li><strong>I/O ‚Üí Memory</strong> (e.g., disk to RAM)</li>
        <li><strong>Memory ‚Üí I/O</strong> (e.g., RAM to display)</li>
        <li><strong>Memory ‚Üí Memory</strong> (block copy)</li>
        <li><strong>Block initialization</strong> (fill memory with a value)</li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> 8237 Internal Registers (per channel)</h3>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">Base Address Register</div>
          <div class="kv-value">16-bit starting address</div>
        </div>
        <div class="kv">
          <div class="kv-label">Current Address Register</div>
          <div class="kv-value">16-bit current transfer address</div>
        </div>
        <div class="kv">
          <div class="kv-label">Base Word Count</div>
          <div class="kv-value">16-bit initial byte count</div>
        </div>
        <div class="kv">
          <div class="kv-label">Current Word Count</div>
          <div class="kv-value">16-bit remaining bytes</div>
        </div>
      </div>
      <p>Plus global registers: Command (8-bit), Mode (4√ó6-bit), Mask (4-bit), Request (4-bit), Status (8-bit), Temporary (8-bit).</p>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> 8237 Key Pins</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Pin</th><th>Function</th></tr></thead>
          <tbody>
            <tr><td><code>DREQ0‚Äì3</code></td><td>DMA request inputs from peripherals (DREQ0 = highest priority)</td></tr>
            <tr><td><code>DACK0‚Äì3</code></td><td>DMA acknowledge outputs to peripherals</td></tr>
            <tr><td><code>HRQ</code></td><td>Hold Request ‚Äî output to CPU's HOLD pin</td></tr>
            <tr><td><code>HLDA</code></td><td>Hold Acknowledge ‚Äî input from CPU's HLDA pin</td></tr>
            <tr><td><code>A0‚ÄìA7</code></td><td>Low 8 address bits (I/O register select in idle; address in active)</td></tr>
            <tr><td><code>DB0‚ÄìDB7</code></td><td>Bidirectional data / upper 8 address bits in DMA mode</td></tr>
            <tr><td><code>ADSTB</code></td><td>Address Strobe ‚Äî latches upper address byte from DB0‚Äì7</td></tr>
            <tr><td><code>AEN</code></td><td>Address Enable ‚Äî enables latched upper address output</td></tr>
            <tr><td><code>IOR', IOW'</code></td><td>I/O Read/Write control</td></tr>
            <tr><td><code>MEMR', MEMW'</code></td><td>Memory Read/Write control</td></tr>
            <tr><td><code>EOP'</code></td><td>End of Process ‚Äî signals transfer completion</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <div class="card">
        <h3><span class="icon purple">‚óÜ</span> DMA Transfer Modes (from Jan 29 lecture)</h3>
        <div class="table-wrap">
          <table>
            <thead><tr><th>Mode</th><th>Behavior</th><th>Use Case</th><th>CPU Impact</th></tr></thead>
            <tbody>
              <tr>
                <td><strong>Single Transfer</strong></td>
                <td>Transfer 1 unit ‚Üí release bus to CPU ‚Üí wait for next DREQ</td>
                <td>Keyboard, slow peripherals with unpredictable timing</td>
                <td>Minimal ‚Äî CPU gets bus back after each transfer</td>
              </tr>
              <tr>
                <td><strong>Block Transfer</strong></td>
                <td>Transfer continuously until word count = 0, then release bus</td>
                <td>Hard disk, floppy ‚Äî block-oriented devices with known data size</td>
                <td>High ‚Äî CPU is locked out for entire block</td>
              </tr>
              <tr>
                <td><strong>Demand Transfer</strong></td>
                <td>Transfer as long as DREQ is active; pause when DREQ drops, resume when it returns</td>
                <td>Variable-rate devices where data availability fluctuates</td>
                <td>Medium ‚Äî CPU gets bus when device isn't ready</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p style="margin-top:8px; color:var(--text-dim); font-size:13px;">Sir Clem (Jan 29): <em>"If you're only going to do a single transfer and never again, just use the CPU. It takes more instructions to set up the DMA than to just do it."</em></p>
      </div>

      <div class="card">
        <h3><span class="icon amber">‚óÜ</span> DMA Timing States: S1-S4 vs S2-S4 Optimization</h3>

        <!-- DMA Timing SVG -->
        <svg viewBox="0 0 700 220" style="width:100%; max-width:700px; margin:12px auto; display:block;">
          <style>
            .state-box { stroke: rgba(255,255,255,0.2); stroke-width: 1; rx: 4; }
            .state-txt { fill: #e2e8f0; font-size: 11px; font-family: 'IBM Plex Mono', monospace; text-anchor: middle; }
            .phase-txt { fill: #94a3b8; font-size: 9px; font-family: 'IBM Plex Mono', monospace; text-anchor: middle; }
          </style>
          <!-- SI/S0 -->
          <rect x="10" y="30" width="50" height="35" class="state-box" fill="rgba(100,116,139,0.2)"/>
          <text x="35" y="52" class="state-txt">SI</text>
          <text x="35" y="75" class="phase-txt">idle</text>
          <rect x="70" y="30" width="50" height="35" class="state-box" fill="rgba(245,158,11,0.15)"/>
          <text x="95" y="52" class="state-txt">S0</text>
          <text x="95" y="75" class="phase-txt">HRQ‚Üí</text>

          <!-- First transfer: S1 S2 S3 S4 (4 states) -->
          <rect x="140" y="30" width="50" height="35" class="state-box" fill="rgba(139,92,246,0.2)"/>
          <text x="165" y="52" class="state-txt" style="fill:#8b5cf6;">S1</text>
          <text x="165" y="20" class="phase-txt" style="fill:#8b5cf6;">A8-A15</text>
          <text x="165" y="12" class="phase-txt" style="fill:#8b5cf6;">on DB</text>
          <rect x="200" y="30" width="50" height="35" class="state-box" fill="rgba(59,130,246,0.2)"/>
          <text x="225" y="52" class="state-txt" style="fill:#3b82f6;">S2</text>
          <rect x="260" y="30" width="50" height="35" class="state-box" fill="rgba(59,130,246,0.2)"/>
          <text x="285" y="52" class="state-txt" style="fill:#3b82f6;">S3</text>
          <rect x="320" y="30" width="50" height="35" class="state-box" fill="rgba(59,130,246,0.2)"/>
          <text x="345" y="52" class="state-txt" style="fill:#3b82f6;">S4</text>
          <text x="265" y="80" class="phase-txt">1st transfer (4 states)</text>

          <!-- Subsequent: S2 S3 S4 only (3 states) -->
          <rect x="390" y="30" width="50" height="35" class="state-box" fill="rgba(34,197,94,0.2)"/>
          <text x="415" y="52" class="state-txt" style="fill:#22c55e;">S2</text>
          <rect x="450" y="30" width="50" height="35" class="state-box" fill="rgba(34,197,94,0.2)"/>
          <text x="475" y="52" class="state-txt" style="fill:#22c55e;">S3</text>
          <rect x="510" y="30" width="50" height="35" class="state-box" fill="rgba(34,197,94,0.2)"/>
          <text x="535" y="52" class="state-txt" style="fill:#22c55e;">S4</text>
          <text x="475" y="80" class="phase-txt">2nd+ transfer (3 states)</text>

          <rect x="580" y="30" width="40" height="35" class="state-box" fill="rgba(34,197,94,0.2)"/>
          <text x="600" y="52" class="state-txt" style="fill:#22c55e;">S2</text>
          <text x="640" y="52" class="state-txt" style="fill:#64748b;">...</text>

          <!-- Arrows -->
          <line x1="60" y1="47" x2="68" y2="47" stroke="#94a3b8" stroke-width="1" marker-end="url(#arrowhead)"/>
          <line x1="120" y1="47" x2="138" y2="47" stroke="#94a3b8" stroke-width="1" marker-end="url(#arrowhead)"/>
          <line x1="370" y1="47" x2="388" y2="47" stroke="#94a3b8" stroke-width="1" marker-end="url(#arrowhead)"/>
          <line x1="560" y1="47" x2="578" y2="47" stroke="#94a3b8" stroke-width="1" marker-end="url(#arrowhead)"/>

          <!-- Explanation -->
          <text x="10" y="115" class="phase-txt" style="fill:#8b5cf6; font-size:10px;">S1: High-order address (A8-A15) output on DB0-DB7, latched by ADSTB</text>
          <text x="10" y="130" class="phase-txt" style="fill:#3b82f6; font-size:10px;">S2-S4: Low-order address (A0-A7) on address pins + data transfer</text>
          <text x="10" y="145" class="phase-txt" style="fill:#22c55e; font-size:10px;">If A8-A15 unchanged ‚Üí skip S1, go straight to S2 (saves 1 state per transfer)</text>

          <!-- When S1 re-triggers -->
          <text x="10" y="170" class="phase-txt" style="fill:#f59e0b; font-size:10px;">S1 re-triggers when: address increments past 256-byte boundary (A8 bit changes)</text>
          <text x="10" y="185" class="phase-txt" style="fill:#ef4444; font-size:10px;">Worst case for 256 bytes: 2√ó S1-S4 + 254√ó S2-S4 (if start addr is NOT boundary-aligned)</text>
        </svg>

        <div class="callout">
          <strong>Memory-to-memory transfers</strong> always use S1-S4 for BOTH source and destination (8 states per transfer) because source and destination addresses are typically in different 256-byte pages. Channel 0 = source address, Channel 1 = destination address.
        </div>
      </div>

      <div class="card">
        <h3><span class="icon cyan">‚óÜ</span> Auto-Initialize & Special Features</h3>
        <div class="kv-grid">
          <div class="kv">
            <div class="kv-label">Auto-Initialize</div>
            <div class="kv-value">After word count reaches 0 (EOP), the base address and word count are automatically reloaded. Useful for repetitive transfers (e.g., always printing from the same buffer).</div>
          </div>
          <div class="kv">
            <div class="kv-label">Mem-to-Mem: Hold Address</div>
            <div class="kv-value">Channel 0 can be programmed to HOLD its address (no increment). Fill destination with same value ‚Äî useful for memory initialization (zeroing out RAM).</div>
          </div>
          <div class="kv">
            <div class="kv-label">EOP' (End of Process)</div>
            <div class="kv-value">Asserted when word count underflows (FFFFh from 0000h). Channel is auto-masked. Can trigger an interrupt to notify CPU.</div>
          </div>
        </div>
      </div>

      <h3><span class="icon green">‚óÜ</span> DMA Operation Sequence</h3>
      <div class="flow">
        <div class="flow-step">‚ë† Peripheral asserts DREQn</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë° 8237 asserts HRQ to CPU</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë¢ CPU grants via HLDA</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë£ 8237 takes bus control</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë§ Activates MEM + I/O signals simultaneously</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë• Data transfers directly</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë¶ Count ‚Üí 0: EOP'</div>
      </div>
    </div>

    <div class="callout">
      <strong>Key advantage:</strong> During a DMA I/O-to-Memory transfer, both <code>IOR'</code> and <code>MEMW'</code> are activated in the <em>same</em> bus cycle ‚Äî data flows from I/O device directly to memory in a single cycle, vs. two cycles with CPU (read then write).
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> DMA Transfer Types ‚Äî Control Signal Detail</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Type</th><th>Direction</th><th>Active Signals</th><th>Notes</th></tr></thead>
          <tbody>
            <tr><td><strong>Read</strong></td><td>Memory ‚Üí I/O</td><td><code>MEMR'</code> + <code>IOW'</code> simultaneously</td><td>DMA sequences address counter for memory</td></tr>
            <tr><td><strong>Write</strong></td><td>I/O ‚Üí Memory</td><td><code>IOR'</code> + <code>MEMW'</code> simultaneously</td><td>DMA sequences address counter for memory</td></tr>
            <tr><td><strong>Verify</strong></td><td>‚Äî</td><td>None (no control lines activated)</td><td>Sequences through address generation only ‚Äî used for testing/debugging</td></tr>
            <tr><td><strong>Mem-to-Mem</strong></td><td>Memory ‚Üí Memory</td><td>See below</td><td>Uses Ch0 (source) + Ch1 (destination)</td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:8px; color:var(--text-dim); font-size:13px;"><strong>Initiating transfers:</strong> Assuming registers are set up, transfers start via DREQx signal asserted by a peripheral, <em>or</em> by the CPU writing to the Request Register (software-initiated).</p>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> Memory-to-Memory Transfers</h3>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">Channel 0 (Source)</div>
          <div class="kv-value">Address counter ‚Üí start of source block. Word count is <strong>don't care</strong> (Ch1 controls transfer length). Set increment or decrement.</div>
        </div>
        <div class="kv">
          <div class="kv-label">Channel 1 (Destination)</div>
          <div class="kv-value">Address counter ‚Üí start of destination block. Word count controls transfer length. Set increment or decrement.</div>
        </div>
        <div class="kv">
          <div class="kv-label">States per transfer</div>
          <div class="kv-value"><strong>4 √ó 2 = 8 states:</strong> first 4 states read from source (Ch0), second 4 states write to destination (Ch1). Data passes through the 8237's internal <strong>Temporary Register</strong>.</div>
        </div>
        <div class="kv">
          <div class="kv-label">EOP Generation</div>
          <div class="kv-value"><strong>Ch1</strong> word count decrementing beyond 0000h causes EOP. Ch0 does <strong>NOT</strong> generate EOP (but does trigger auto-initialize on Ch0 if enabled).</div>
        </div>
        <div class="kv">
          <div class="kv-label">Ch0 "Hold" Mode</div>
          <div class="kv-value">Ch0 can be programmed to hold its source address (no incr/decr) ‚Äî useful for <strong>memory initialization</strong> (e.g., filling a block with a constant value).</div>
        </div>
        <div class="kv">
          <div class="kv-label">Auto-Initialize</div>
          <div class="kv-value">May be used on both Ch0 and Ch1. If used, <strong>set Ch0 word count = Ch1 word count</strong> so both re-initialize properly.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> Programming the 8237 ‚Äî Register Map</h3>
      <p style="margin-bottom:12px;">Each channel has its own set of registers. The whole 8237 also has global registers shared across all channels.</p>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Scope</th><th>Register</th><th>Width</th><th>Notes</th></tr></thead>
          <tbody>
            <tr><td rowspan="6"><strong>Per Channel<br>(√ó4)</strong></td><td>Base Address Register</td><td>16 bits</td><td>Starting address (write-only)</td></tr>
            <tr><td>Base Word Count Register</td><td>16 bits</td><td>Starting transfer count (write-only)</td></tr>
            <tr><td>Current Address Register</td><td>16 bits</td><td>Address being used now (read/write)</td></tr>
            <tr><td>Current Word Count Register</td><td>16 bits</td><td>Remaining count (read/write)</td></tr>
            <tr><td>Mode Register</td><td>6 bits</td><td>Transfer mode, type, auto-init, incr/decr</td></tr>
            <tr><td>Mask Register</td><td>1 bit</td><td>Masks (disables) the channel's DREQ</td></tr>
          </tbody>
        </table>
      </div>
      <div class="table-wrap" style="margin-top:12px;">
        <table>
          <thead><tr><th>Scope</th><th>Register</th><th>Notes</th></tr></thead>
          <tbody>
            <tr><td rowspan="4"><strong>Global<br>(√ó1)</strong></td><td>Command Register</td><td>Overall 8237 operating mode</td></tr>
            <tr><td>Status Register</td><td>TC flags, DREQ status for each channel</td></tr>
            <tr><td>Temporary Register</td><td>Holds data byte during mem-to-mem transfers</td></tr>
            <tr><td>Request Register</td><td>Software-initiated DMA requests</td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:8px; color:var(--text-dim); font-size:13px;"><strong>First/Last Flip-Flop:</strong> 16-bit registers are accessed via an 8-bit data bus in two consecutive I/O operations. A flip-flop tracks whether the next byte is low (first) or high (last). <code>Clear First/Last F/F</code> must be issued before programming to ensure the flip-flop is in a known state.</p>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> 8237 Register Access Addresses</h3>
      <p style="margin-bottom:12px;">Software commands are special I/O operations to the 8237's address space that change operational modes. The address lines A0‚ÄìA3 combined with IOR'/IOW' select the operation:</p>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Operation</th><th>A3</th><th>A2</th><th>A1</th><th>A0</th><th>IOR'</th><th>IOW'</th></tr></thead>
          <tbody>
            <tr><td>Read Status Register</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
            <tr><td>Write Command Register</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
            <tr><td>Write Request Register</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
            <tr><td>Write Single Mask Bit</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
            <tr><td>Write Mode Register</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
            <tr><td>Set First/Last F/F</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
            <tr><td>Clear First/Last F/F</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
            <tr><td>Master Clear</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
            <tr><td>Write All Mask Bits</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
            <tr><td>Read All Mask Bits</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:8px; color:var(--text-dim); font-size:13px;">Per-channel address/word-count registers use A0‚ÄìA3 (low nibble = channel √ó 2), plus the First/Last flip-flop state determines low or high byte, and the data bus carries either A0‚ÄìA7 (first) or A8‚ÄìA15 (last).</p>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Cascading 8237s</h3>
      <p>Similar to cascading 8259 PICs: a <strong>1st-level</strong> (master) 8237 connects HRQ/HLDA to the CPU. Its DREQ/DACK outputs connect to HRQ/HLDA of <strong>2nd-level</strong> (slave) 8237s.</p>
      <p style="margin-top:8px;">When a slave channel needs the bus, it asserts HRQ to the master's DREQn input. The master arbitrates and sends HLDA (via DACKn) back to the slave. The slave then performs the actual transfer.</p>
      <p style="margin-top:8px;">This allows expansion beyond 4 DMA channels while maintaining a single HRQ/HLDA interface with the CPU. In the IBM PC/AT, two 8237s were cascaded ‚Äî channel 0 of the master was used for the cascade connection, giving 7 usable channels.</p>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- MODULE 5: PC Architecture & Modern DRAM -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="section" id="pc-arch">
    <span class="section-num">05 ¬∑ PC/XT ARCHITECTURE</span>
    <h2>IBM PC/XT System Design</h2>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> IBM 5150 vs 5160</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Feature</th><th>IBM 5150 (PC)</th><th>IBM 5160 (PC/XT)</th></tr></thead>
          <tbody>
            <tr><td>CPU</td><td>8088 @ 4.77 MHz</td><td>8088 @ 4.77 MHz</td></tr>
            <tr><td>RAM</td><td>16 KB</td><td>256 KB</td></tr>
            <tr><td>Crystal</td><td colspan="2">14.318 MHz (√∑3 by 8284 = 4.77 MHz CLK)</td></tr>
            <tr><td>Design</td><td colspan="2"><strong>"Open"</strong> ‚Äî allows 3rd party hardware/software development</td></tr>
            <tr><td>Motherboard</td><td colspan="2">Called a <strong>"planar"</strong> by IBM</td></tr>
          </tbody>
        </table>
      </div>
      <div class="callout tip">
        <strong>From lecture:</strong> The 14.318 MHz crystal was chosen because √∑4 = 3.579545 MHz (NTSC color burst frequency for early composite video output). 14.318 √∑ 3 = 4.77 MHz.
      </div>
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> IBM PC/XT Component Summary</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Subsystem</th><th>Chip</th><th>Details</th></tr></thead>
          <tbody>
            <tr><td><strong>Microprocessor</strong></td><td>Intel 8088</td><td>16-bit internal, 8-bit external data bus</td></tr>
            <tr><td><strong>Bus Controller</strong></td><td>Intel 8288</td><td>Generates MEMR, MEMW, IOR, IOW from status signals</td></tr>
            <tr><td><strong>Memory</strong></td><td>‚Äî</td><td>64K ROM (BIOS ~8K + BASIC ~32K) + 256K DRAM</td></tr>
            <tr><td><strong>Timer Circuit</strong></td><td>Intel 8253 PIT</td><td>Programmable Interval Timer ‚Äî 3 channels: Tone generator, Clock tick (IRQ0), <strong>DRAM refresh interval</strong></td></tr>
            <tr><td><strong>Interrupt Controller</strong></td><td>Intel 8259 PIC</td><td>8 interrupt request lines with priority resolution; 5 IRQ lines on expansion bus (IRQ2‚Äì7, with IRQ0 & IRQ1 used on planar)</td></tr>
            <tr><td><strong>DMA Controller</strong></td><td>Intel 8237 DMAC</td><td>4 DMA request channels</td></tr>
            <tr><td><strong>Peripheral Control</strong></td><td>Intel 8255 PPI</td><td>Programmable Peripheral Interface ‚Äî keyboard controller, speaker control, input switch functions</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> PC/XT Expansion Bus (62-pin ISA)</h3>
      <p style="margin-bottom:12px;">The expansion bus allows add-in cards (video, disk controllers, serial ports, etc.) to be added to the system.</p>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">Address Bus</div>
          <div class="kv-value">A0‚ÄìA19 (20-bit, full 1 MB addressing for memory). Only <strong>10 bits</strong> (A0‚ÄìA9) decoded for I/O addresses (= 1024 I/O locations, though 8088 can address 64K).</div>
        </div>
        <div class="kv">
          <div class="kv-label">Data Bus</div>
          <div class="kv-value">D0‚ÄìD7 (8-bit data bus)</div>
        </div>
        <div class="kv">
          <div class="kv-label">Control Signals</div>
          <div class="kv-value">MEMR', MEMW', IOR', IOW' (active low), ALE</div>
        </div>
        <div class="kv">
          <div class="kv-label">DMA Signals</div>
          <div class="kv-value">DREQ0‚Äì3, DACK0'‚Äì3', AEN, T/C</div>
        </div>
        <div class="kv">
          <div class="kv-label">Interrupt Requests</div>
          <div class="kv-value">IRQ2‚ÄìIRQ7 (active high, edge-triggered)</div>
        </div>
        <div class="kv">
          <div class="kv-label">Clock Signals</div>
          <div class="kv-value">CLK (4.77 MHz), OSC (14.318 MHz), RESET DRV</div>
        </div>
        <div class="kv">
          <div class="kv-label">Wait/Error</div>
          <div class="kv-value">IO CH RDY (I/O Channel Ready ‚Äî pull low to insert wait states), IO CH CK (channel check ‚Äî parity error)</div>
        </div>
        <div class="kv">
          <div class="kv-label">Power</div>
          <div class="kv-value">+5V, -5V, +12V, -12V, GND</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> PC/XT Memory Map Organization</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Address Range</th><th>Size</th><th>Usage</th></tr></thead>
          <tbody>
            <tr><td><code>00000h ‚Äì 003FFh</code></td><td>1 KB</td><td><strong>Interrupt Vector Table</strong> (256 vectors √ó 4 bytes)</td></tr>
            <tr><td><code>00400h ‚Äì 3FFFFh</code></td><td>~256 KB</td><td>Read/Write Memory on System Board (DRAM)</td></tr>
            <tr><td><code>40000h ‚Äì 9FFFFh</code></td><td>384 KB</td><td>Read/Write Memory (expansion ‚Äî system board or expansion bus)</td></tr>
            <tr><td><code>A0000h ‚Äì BFFFFh</code></td><td>128 KB</td><td><strong>Display Buffer (reserved)</strong></td></tr>
            <tr><td style="padding-left:24px;"><code>B0000h ‚Äì B7FFFh</code></td><td>32 KB</td><td>Monochrome adapter (only ~4 KB used)</td></tr>
            <tr><td style="padding-left:24px;"><code>B8000h ‚Äì BCFFFh</code></td><td>20 KB</td><td>Color Graphics Adapter (only ~16 KB used)</td></tr>
            <tr><td><code>C0000h ‚Äì EFFFFh</code></td><td>192 KB</td><td>Read-Only Memory ‚Äî expansion and control (e.g., fixed disk controller ROM)</td></tr>
            <tr><td><code>F0000h ‚Äì FFFFFh</code></td><td>64 KB</td><td><strong>Base System ROM</strong> ‚Äî BIOS (~8 KB) + BASIC interpreter (~32 KB)</td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:8px; color:var(--text-dim); font-size:13px;">The "640 KB barrier" comes from the fact that 00000h‚Äì9FFFFh = 640 KB is the maximum conventional RAM before the reserved display/ROM regions begin.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> PC/XT I/O Map Organization</h3>
      <p style="margin-bottom:12px;">I/O addresses use only 10 bits (A0‚ÄìA9), giving 1024 locations total. If the MSB (A9) is <strong>0</strong>, the device is on the system board (planar). If A9 is <strong>1</strong>, it's on an expansion card.</p>
      <div class="table-wrap">
        <table>
          <thead><tr><th colspan="3" style="text-align:center;">System Board I/O Addresses</th></tr>
          <tr><th>Device</th><th>Chip</th><th>Address Range</th></tr></thead>
          <tbody>
            <tr><td>DMA Controller</td><td>8237</td><td><code>0000h ‚Äì 000Fh</code></td></tr>
            <tr><td>Interrupt Controller</td><td>8259</td><td><code>0020h ‚Äì 0021h</code></td></tr>
            <tr><td>Timer Circuit</td><td>8253</td><td><code>0040h ‚Äì 0043h</code></td></tr>
            <tr><td>Peripheral Interface</td><td>8255</td><td><code>0060h ‚Äì 0063h</code></td></tr>
            <tr><td>DMA Page Registers</td><td>‚Äî</td><td><code>0080h ‚Äì 0083h</code></td></tr>
            <tr><td>NMI Mask Bit</td><td>‚Äî</td><td><code>00A0h</code></td></tr>
          </tbody>
        </table>
      </div>
      <div class="table-wrap" style="margin-top:12px;">
        <table>
          <thead><tr><th colspan="2" style="text-align:center;">Card Slot I/O Addresses (Expansion Bus)</th></tr>
          <tr><th>Device</th><th>Address Range</th></tr></thead>
          <tbody>
            <tr><td>Printer Port (LPT1)</td><td><code>0378h ‚Äì 037Fh</code></td></tr>
            <tr><td>Monochrome Display Adapter</td><td><code>03B0h ‚Äì 03BFh</code></td></tr>
            <tr><td>Color Graphics Adapter</td><td><code>03D0h ‚Äì 03DFh</code></td></tr>
            <tr><td>Floppy Disk Controller</td><td><code>03F0h ‚Äì 03F7h</code></td></tr>
            <tr><td>Serial Port (COM1)</td><td><code>03F8h ‚Äì 03FFh</code></td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="callout">
      <strong>DRAM Refresh on the XT:</strong> The 8253 PIT (timer channel 1) generates a periodic interrupt every <strong>15.625 ¬µs</strong>. This triggers DMA channel 0 to perform a "dummy" read cycle, which sequences addresses to the DRAM ‚Äî performing <strong>distributed refresh</strong>. This is why DMA Ch0 is reserved on the PC/XT and not available for I/O devices.
    </div>
  </div>

  <!-- Modern DRAM -->
  <div class="section" id="modern-dram">
    <span class="section-num">05.1 ¬∑ MODERN DRAM TECHNOLOGIES</span>
    <h2>FPM, EDO, SDRAM, RDRAM & DDR1‚Äì4</h2>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> FPM & EDO DRAM</h3>
      <p><strong>FPM (Fast Page Mode):</strong> First innovation in DRAM access. After RAS' asserts, all memory cells on the selected row are active and buffered in sense amplifiers. Subsequent accesses within the same row only need CAS' toggling ‚Äî access time becomes <strong>tCAC only</strong> (no tRAC overhead). CAS' is toggled for each column within the open row.</p>
      <p style="margin-top:8px;"><strong>EDO (Extended Data Out):</strong> During CAS precharge, conventional DRAM turns output data OFF, shortening the data window. CAS normally needs to be held low longer to maintain a usable data window, which slows access. EDO latches data internally so it <strong>continues to be accessible during CAS precharge</strong>. This allows CAS to be cycled faster, yielding ~30% faster page-mode performance.</p>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> FPM vs EDO ‚Äî Specific Timing Values</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Parameter</th><th>Description</th><th>FPM</th><th>EDO</th></tr></thead>
          <tbody>
            <tr><td><strong>tRAC</strong></td><td>Access time from RAS'</td><td>60 ns</td><td>60 ns</td></tr>
            <tr><td><strong>tCAC</strong></td><td>Access time from CAS'</td><td>15 ns</td><td>15 ns</td></tr>
            <tr><td><strong>tRC</strong></td><td>Cycle time (non-page mode)</td><td>110 ns</td><td>110 ns</td></tr>
            <tr><td><strong>tPC</strong></td><td>Cycle time (page mode)</td><td><strong>40 ns</strong></td><td><strong>25 ns</strong></td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:8px; color:var(--text-dim); font-size:13px;">The key difference is tPC ‚Äî EDO's internal latch allows 25 ns page-mode cycle vs FPM's 40 ns, a <strong>37.5% improvement</strong>. Both FPM and EDO are effective up to ~66 MHz bus speeds; beyond that, asynchronous timing fails.</p>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> SDRAM (Synchronous DRAM)</h3>
      <p>Operations synchronized to a <strong>clock signal</strong> ‚Äî unlike asynchronous FPM/EDO. Control signals applied on rising edge; data out on the next rising edge. FPM and EDO are only good up to 66 MHz ‚Äî need faster access for 100 MHz and above.</p>
      <div class="kv-grid" style="margin-top:12px;">
        <div class="kv">
          <div class="kv-label">Internal Burst Counter</div>
          <div class="kv-value">Generates next addresses internally for burst cycles ‚Äî CPU only provides starting address</div>
        </div>
        <div class="kv">
          <div class="kv-label">Internal Interleaving</div>
          <div class="kv-value">Has internal bank structure (e.g., top bank + bottom bank) for overlapped access</div>
        </div>
        <div class="kv">
          <div class="kv-label">Command-Driven</div>
          <div class="kv-value">All operations driven by commands, not just signal levels</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> SDRAM Commands</h3>
      <p style="margin-bottom:8px;">Commands are given via combinations of RAS', CAS', W', A10, and A11 bit values:</p>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Command</th><th>Purpose</th></tr></thead>
          <tbody>
            <tr><td><strong>Mode Register Set</strong></td><td>Program burst type/length, CAS latency (1, 2, or 3 clocks)</td></tr>
            <tr><td><strong>Bank Activate</strong></td><td>Select a bank and provide Row Address (opens a page)</td></tr>
            <tr><td><strong>Read</strong></td><td>Column Address Entry ‚Äî data comes out after CAS latency</td></tr>
            <tr><td><strong>Write</strong></td><td>Column Address Entry ‚Äî data written immediately</td></tr>
            <tr><td><strong>Bank Deactivate</strong></td><td>Precharge the bank (close the row)</td></tr>
            <tr><td><strong>CBR Refresh</strong></td><td>CAS-before-RAS auto-refresh</td></tr>
            <tr><td><strong>Self-Refresh</strong></td><td>Internal refresh without external clock (power-saving)</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> SDRAM Basic Read Operation Sequence</h3>
      <div class="flow">
        <div class="flow-step">‚ë† Program Mode Register (burst type, length, CAS latency)</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë° Bank Activate + Row Address</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë¢ Issue READ + Column Address</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë£ Wait 1-3 clock latency cycles</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë§ Data out (burst continues automatically)</div>
        <span class="flow-arrow">‚Üí</span>
        <div class="flow-step">‚ë• Bank Deactivate</div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> RDRAM (Rambus DRAM)</h3>
      <p>The problem with wide parallel buses (12-16 address + 4 control + 64 data lines): requires very careful layout to minimize <strong>bus skew, ringing, noise, and crosstalk</strong> (signal integrity). Rambus idea: minimize number of lines but run at much higher frequency.</p>
      <div class="kv-grid" style="margin-top:8px;">
        <div class="kv">
          <div class="kv-label">Data Path</div>
          <div class="kv-value">Intel + Rambus: <strong>400 MHz, 16-bit serial data path</strong></div>
        </div>
        <div class="kv">
          <div class="kv-label">Dual Serial Bus</div>
          <div class="kv-value">A second serial bus communicates Row/Column address simultaneously ‚Äî allows reading one address while receiving column info for the 2nd operation and row info for the 3rd</div>
        </div>
        <div class="kv">
          <div class="kv-label">Efficiency</div>
          <div class="kv-value">Results in a utilization efficiency of <strong>95%</strong></div>
        </div>
        <div class="kv">
          <div class="kv-label">Module</div>
          <div class="kv-value">RIMM ‚Äî 184 pins, requires all sockets populated (or use continuity modules)</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> SDR vs DDR ‚Äî The Fundamental Difference</h3>
      <p><strong>Single Data Rate (SDR) SDRAM:</strong> Memory core and I/O buffers run at the <strong>same clock speed</strong>. Each output buffer releases ONE bit per clock cycle. Core frequency = data frequency.</p>
      <p style="margin-top:8px;"><strong>Dual Data Rate (DDR) SDRAM:</strong> Every I/O buffer releases <strong>TWO bits per clock cycle</strong> ‚Äî one on the rising edge, one on the falling edge. Data signals are called "DQ" (Data in Queue). Two bits from the memory core go to the data buffer, where one bit is released per clock edge. I/O and memory core still run at the <strong>same clock rate</strong>, but the data bus effectively runs at 2√ó the clock frequency.</p>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> The DDR Design Challenge: Speed vs Power</h3>
      <p>Speed isn't the only issue ‚Äî memory modules can consume up to <strong>40W</strong> for a full population (hence heat sinks on high-performance DIMMs). Each DDR generation addresses both speed and power.</p>
      <div class="kv-grid" style="margin-top:8px;">
        <div class="kv">
          <div class="kv-label">Power Solution</div>
          <div class="kv-value">Drop supply voltage each generation (2.5V ‚Üí 1.8V ‚Üí 1.5V ‚Üí 1.2V). Lower voltage = less power, but also smaller signal swing ‚Üí more signal integrity challenges.</div>
        </div>
        <div class="kv">
          <div class="kv-label">Signal Integrity</div>
          <div class="kv-value">Smaller voltage swing causes "wimpy" rise/fall, increasing uncertainty of when signals switch between 1/0. DDR introduces a <strong>Data Strobe (DQS)</strong> signal (aka "Clock Forwarding") to mitigate this.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> DDR2 ‚Äî Need for Speed</h3>
      <p><strong>Key innovation:</strong> <strong>4-bit prefetch</strong> from the memory core. The memory module needs to pump out 4 bits, but there are no clock edges left (DDR already uses both edges). Solution: run the <strong>I/O buffer at 2√ó the core frequency</strong>.</p>
      <div class="kv-grid" style="margin-top:8px;">
        <div class="kv">
          <div class="kv-label">Architecture</div>
          <div class="kv-value">Core frequency stays the same, but I/O buffers run at <strong>2√ó core frequency</strong>. This allows pumping out the 4 prefetched bits (2 per clock edge √ó 2 edges per I/O clock cycle).</div>
        </div>
        <div class="kv">
          <div class="kv-label">Voltage</div>
          <div class="kv-value"><strong>1.8V</strong> (down from DDR's 2.5V). Lower voltage ‚Üí smaller output swing ‚Üí smaller rise/fall time.</div>
        </div>
        <div class="kv">
          <div class="kv-label">Differential DQS</div>
          <div class="kv-value">Single DQS requires a reference voltage to determine when to switch. DDR2 introduces <strong>differential DQS (DQS and /DQS)</strong> ‚Äî the two strobes are measured against each other, removing reference voltage uncertainty.</div>
        </div>
        <div class="kv">
          <div class="kv-label">On-Die Termination (ODT)</div>
          <div class="kv-value">DDR had terminating resistors on the DDR module. DDR2 moves them <strong>inside the memory chip</strong> itself (on-die). Switch-controlled to allow disconnection when the module isn't active ‚Äî prevents inactive modules from absorbing/weakening signals.</div>
        </div>
        <div class="kv">
          <div class="kv-label">OCD Calibration</div>
          <div class="kv-value">Off-Chip Driver Calibration ‚Äî accounts for impedances, manufacturer differences, minimizes overshoot/undershoot and DQ-DQS misalignment.</div>
        </div>
      </div>

      <!-- SDRAM/DDR/DDR2 architecture comparison SVG -->
      <svg viewBox="0 0 700 280" style="width:100%; max-width:700px; margin:16px auto; display:block;">
        <style>
          .arch-label { fill: #e2e8f0; font-size: 13px; font-family: 'IBM Plex Mono', monospace; font-weight: 600; }
          .arch-detail { fill: #94a3b8; font-size: 10px; font-family: 'IBM Plex Mono', monospace; }
          .arch-box { rx: 4; stroke-width: 1.5; }
        </style>
        <!-- SDRAM -->
        <text x="15" y="25" class="arch-label">SDRAM</text>
        <rect x="15" y="35" width="90" height="40" class="arch-box" fill="rgba(59,130,246,0.15)" stroke="#3b82f6"/>
        <text x="38" y="58" class="arch-detail" style="fill:#3b82f6;">Mem Core</text>
        <text x="120" y="45" class="arch-detail">‚Üí</text>
        <rect x="140" y="35" width="70" height="40" class="arch-box" fill="rgba(59,130,246,0.15)" stroke="#3b82f6"/>
        <text x="152" y="58" class="arch-detail" style="fill:#3b82f6;">I/O Buf</text>
        <text x="225" y="45" class="arch-detail">‚Üí</text>
        <text x="245" y="58" class="arch-detail" style="fill:#e2e8f0;">Data Bus</text>
        <text x="400" y="45" class="arch-detail">Core: 100 MHz</text>
        <text x="400" y="58" class="arch-detail">Clock: 100 MHz</text>
        <text x="400" y="71" class="arch-detail" style="fill:#3b82f6;">Data: 100 MHz</text>

        <!-- DDR -->
        <text x="15" y="110" class="arch-label">DDR</text>
        <rect x="15" y="120" width="90" height="40" class="arch-box" fill="rgba(34,197,94,0.15)" stroke="#22c55e"/>
        <text x="38" y="143" class="arch-detail" style="fill:#22c55e;">Mem Core</text>
        <line x1="105" y1="132" x2="140" y2="132" stroke="#22c55e" stroke-width="1"/>
        <line x1="105" y1="148" x2="140" y2="148" stroke="#22c55e" stroke-width="1"/>
        <text x="115" y="128" class="arch-detail" style="font-size:8px;">2n</text>
        <rect x="140" y="120" width="70" height="40" class="arch-box" fill="rgba(34,197,94,0.15)" stroke="#22c55e"/>
        <text x="152" y="143" class="arch-detail" style="fill:#22c55e;">I/O Buf</text>
        <text x="225" y="133" class="arch-detail">‚Üí</text>
        <text x="245" y="143" class="arch-detail" style="fill:#e2e8f0;">Data Bus</text>
        <text x="400" y="128" class="arch-detail">Core: 100 MHz</text>
        <text x="400" y="141" class="arch-detail">Clock: 100 MHz</text>
        <text x="400" y="154" class="arch-detail" style="fill:#22c55e;">Data: 200 MHz</text>

        <!-- DDR2 -->
        <text x="15" y="195" class="arch-label">DDR2</text>
        <rect x="15" y="205" width="90" height="40" class="arch-box" fill="rgba(245,158,11,0.15)" stroke="#f59e0b"/>
        <text x="38" y="228" class="arch-detail" style="fill:#f59e0b;">Mem Core</text>
        <line x1="105" y1="215" x2="140" y2="215" stroke="#f59e0b" stroke-width="1"/>
        <line x1="105" y1="222" x2="140" y2="222" stroke="#f59e0b" stroke-width="1"/>
        <line x1="105" y1="229" x2="140" y2="229" stroke="#f59e0b" stroke-width="1"/>
        <line x1="105" y1="236" x2="140" y2="236" stroke="#f59e0b" stroke-width="1"/>
        <text x="115" y="212" class="arch-detail" style="font-size:8px;">4n</text>
        <rect x="140" y="205" width="70" height="40" class="arch-box" fill="rgba(245,158,11,0.15)" stroke="#f59e0b"/>
        <text x="152" y="228" class="arch-detail" style="fill:#f59e0b;">I/O Buf</text>
        <text x="225" y="218" class="arch-detail">‚Üí</text>
        <text x="245" y="228" class="arch-detail" style="fill:#e2e8f0;">Data Bus</text>
        <text x="400" y="213" class="arch-detail">Core: 100 MHz</text>
        <text x="400" y="226" class="arch-detail" style="fill:#f59e0b;">Clock: 200 MHz</text>
        <text x="400" y="239" class="arch-detail" style="fill:#f59e0b;">Data: 400 MHz</text>
      </svg>
    </div>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> DDR vs DDR2 ‚Äî Full Specification Comparison</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Parameter</th><th>DDR (DDR-I)</th><th>DDR2 (DDR-II)</th></tr></thead>
          <tbody>
            <tr><td>Data Rate</td><td>200 / 266 / 333 / 400 Mbps</td><td>400 / 533 / (667) Mbps</td></tr>
            <tr><td>Bus Frequency</td><td>100 / 133 / 166 / 200 MHz</td><td>200 / 266 / (333) MHz</td></tr>
            <tr><td>DRAM Core Frequency</td><td>100 / 133 / 166 / 200 MHz</td><td>100 / 133 / (166) MHz</td></tr>
            <tr><td>Prefetch Size</td><td><strong>2 bit</strong></td><td><strong>4 bit</strong></td></tr>
            <tr><td>Burst Length</td><td>2 / 4 / 8</td><td>4 / 8</td></tr>
            <tr><td>Data Strobe</td><td>Single DQS</td><td><strong>Differential: DQS, /DQS</strong></td></tr>
            <tr><td>CAS Latency</td><td>1.5, 2, 2.5</td><td>3+, 4, 5</td></tr>
            <tr><td>Write Latency</td><td>1T</td><td>Read Latency ‚àí 1</td></tr>
            <tr><td>Core Voltage (VDD)</td><td><strong>2.5V</strong></td><td><strong>1.8V</strong></td></tr>
            <tr><td>I/O Voltage (VDDQ)</td><td>SSTL_2 (2.5V)</td><td>SSTL_1.8 (1.8V)</td></tr>
            <tr><td>Packaging</td><td>TSOP (II), TBGA</td><td>FBGA</td></tr>
            <tr><td>Command Set</td><td>‚Äî</td><td>Same as DDR I</td></tr>
            <tr><td>New Features</td><td>‚Äî</td><td>ODT, OCD calibration, Posted CAS, Additive Latency</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> DDR3 ‚Äî Further Speed and Efficiency</h3>
      <p style="margin-bottom:12px;">Key improvements: 800‚Äì1600 Mbits/sec per pin, device capacity up to 8 Gbits, <strong>1.5V</strong> operation, more power-down options, simplified board design, improved timings. But all at a <strong>design price</strong> (more complex calibration).</p>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">Prefetch</div>
          <div class="kv-value"><strong>8n (8-bit prefetch)</strong> ‚Äî double DDR2's 4n</div>
        </div>
        <div class="kv">
          <div class="kv-label">I/O Impedance Calibration</div>
          <div class="kv-value">DDR2 used off-chip calibration. DDR3 has built-in calibration via a dedicated <strong>ZQ pin</strong> for impedance matching, simplifying PCB design.</div>
        </div>
        <div class="kv">
          <div class="kv-label">Fly-By Architecture</div>
          <div class="kv-value">DDR2 uses T (or star) topology for routing. DDR3 switches to <strong>fly-by topology</strong>: chip select/address/control signals travel in series past each chip. Reduces simultaneous switching noise (SSN) but introduces timing skew between modules.</div>
        </div>
        <div class="kv">
          <div class="kv-label">Write Leveling</div>
          <div class="kv-value">Because fly-by architecture means each DRAM chip sees the command at a different time, the memory controller must launch DQ and DQS signals per-module to equalize timing. This calibration process is called <strong>write leveling</strong>.</div>
        </div>
        <div class="kv">
          <div class="kv-label">Read Leveling (Bit-Skew Compensation)</div>
          <div class="kv-value">Write leveling fixes inter-module skew. Individual data bits still have skew from trace length and propagation variations (board issues). <strong>Read leveling</strong> compensates for this at the bit level using IODELAY elements (75ps tap delays).</div>
        </div>
        <div class="kv">
          <div class="kv-label">Timing Calibration</div>
          <div class="kv-value">Read is <strong>edge-timed</strong> (DQS edge-aligned with DQ), while write is <strong>center-aligned</strong> (DQS transitions in the middle of the DQ data eye). DQS must be adjusted to provide the best timing for both operations.</div>
        </div>
        <div class="kv">
          <div class="kv-label">VT Variation Tracking</div>
          <div class="kv-value">Voltage and temperature variations alter timing and impedance. DDR3's memory controller sweeps timing parameters to find optimal values.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> DDR2 vs DDR3 ‚Äî Specification Comparison</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Feature</th><th>DDR2</th><th>DDR3</th></tr></thead>
          <tbody>
            <tr><td>Data Rate</td><td>400‚Äì1066 Mbits/s</td><td><strong>800‚Äì1600 Mbits/s</strong></td></tr>
            <tr><td>VDDQ</td><td>1.8V</td><td><strong>1.5V</strong></td></tr>
            <tr><td>Banks</td><td>4 or 8</td><td><strong>8</strong></td></tr>
            <tr><td>Prefetch</td><td>4n</td><td><strong>8n</strong></td></tr>
            <tr><td>Burst Length</td><td>4 or 8</td><td>8 or "chop to 4"</td></tr>
            <tr><td>DQS</td><td>Single or differential</td><td><strong>Differential only</strong></td></tr>
            <tr><td>Write Leveling</td><td>No</td><td><strong>Yes</strong></td></tr>
            <tr><td>MPR (Multi-Purpose Register)</td><td>No</td><td><strong>Yes</strong></td></tr>
            <tr><td>Reset</td><td>No</td><td><strong>Yes</strong></td></tr>
            <tr><td>DQ Calibration</td><td>Off-chip</td><td><strong>ZQ pin (on-chip)</strong></td></tr>
            <tr><td>ODT</td><td>Yes</td><td>Yes</td></tr>
            <tr><td>DIMM Topology</td><td>Conventional (T/star)</td><td><strong>Fly-by</strong></td></tr>
            <tr><td>Device Capacity</td><td>256 Mbits ‚Äì 4 Gbits</td><td><strong>512 Mbits ‚Äì 8 Gbits</strong></td></tr>
          </tbody>
        </table>
      </div>
      <div class="callout tip" style="margin-top:12px;">
        <strong>Latency paradox:</strong> DDR2 typical JEDEC latencies are 5-5-5-15. DDR3 latencies are numerically higher: <strong>7-7-7-20</strong> (DDR3-1066) and <strong>8-8-8-24</strong> (DDR3-1333). However, because the I/O bus clock cycles are <em>shorter</em>, the actual time interval is similar (~10 ns in both cases). The higher numbers don't mean DDR3 is "slower" ‚Äî they're measured in faster clock ticks.
      </div>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> DDR4 ‚Äî Current Generation</h3>
      <p>Primary advantages over DDR3: higher module density, lower voltage, higher data rates.</p>
      <div class="kv-grid" style="margin-top:8px;">
        <div class="kv">
          <div class="kv-label">Voltage</div>
          <div class="kv-value"><strong>1.2V ‚Äì 1.4V</strong> (vs DDR3's 1.5V / 1.65V)</div>
        </div>
        <div class="kv">
          <div class="kv-label">Frequency</div>
          <div class="kv-value"><strong>800 ‚Äì 4266 MHz</strong> (vs DDR3's 400 ‚Äì 1067 MHz)</div>
        </div>
        <div class="kv">
          <div class="kv-label">Max DIMM Capacity</div>
          <div class="kv-value">Theoretically up to <strong>512 GiB</strong> per DIMM (vs DDR3's 128 GiB theoretical max)</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> DDR Evolution Summary Table</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Feature</th><th>DDR</th><th>DDR2</th><th>DDR3</th><th>DDR4</th></tr></thead>
          <tbody>
            <tr><td>Prefetch</td><td>2n</td><td>4n</td><td>8n</td><td>8n</td></tr>
            <tr><td>Core Voltage</td><td>2.5V</td><td>1.8V</td><td>1.5V</td><td>1.2V</td></tr>
            <tr><td>Data Strobe</td><td>Single DQS</td><td>Differential DQS</td><td>Differential DQS</td><td>Differential DQS</td></tr>
            <tr><td>Termination</td><td>Module</td><td>On-die (ODT)</td><td>On-die (ODT)</td><td>On-die (ODT)</td></tr>
            <tr><td>Impedance Cal.</td><td>‚Äî</td><td>Off-chip (OCD)</td><td>On-chip (ZQ)</td><td>On-chip (ZQ)</td></tr>
            <tr><td>Topology</td><td>‚Äî</td><td>T / Star</td><td>Fly-by</td><td>Fly-by</td></tr>
            <tr><td>Write Leveling</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td></tr>
            <tr><td>Max Data Rate</td><td>400 Mbps</td><td>667 Mbps</td><td>1600 Mbps</td><td>4266 Mbps</td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:8px; color:var(--text-dim); font-size:13px;"><strong>Pattern:</strong> Each DDR generation doubles prefetch width, lowers voltage, increases I/O buffer speed, and adds progressively more calibration/compensation features to deal with ever-tighter signal integrity margins.</p>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Memory Technology Evolution Timeline</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Technology</th><th>Sync?</th><th>Key Innovation</th><th>Typical Speed</th></tr></thead>
          <tbody>
            <tr><td>FPM DRAM</td><td>Async</td><td>Page mode access (tCAC only for subsequent)</td><td>~25 MHz</td></tr>
            <tr><td>EDO DRAM</td><td>Async</td><td>Internal latch ‚Äî data persists during CAS precharge</td><td>~40 MHz (tPC=25ns)</td></tr>
            <tr><td>SDRAM</td><td><strong>Sync</strong></td><td>Clock-synchronized, burst counter, command-driven</td><td>66‚Äì133 MHz</td></tr>
            <tr><td>RDRAM</td><td>Sync</td><td>Narrow 16-bit serial bus @ 400 MHz, 95% utilization</td><td>400 MHz+</td></tr>
            <tr><td>DDR</td><td>Sync</td><td>Double-edge transfer (2n prefetch), DQS strobe</td><td>100‚Äì200 MHz (200‚Äì400 MT/s)</td></tr>
            <tr><td>DDR2</td><td>Sync</td><td>4n prefetch, 2√ó I/O clock, differential DQS, ODT, 1.8V</td><td>200‚Äì333 MHz (400‚Äì667 MT/s)</td></tr>
            <tr><td>DDR3</td><td>Sync</td><td>8n prefetch, fly-by topology, write/read leveling, ZQ, 1.5V</td><td>400‚Äì800 MHz (800‚Äì1600 MT/s)</td></tr>
            <tr><td>DDR4</td><td>Sync</td><td>Higher density (512 GiB/DIMM), 1.2V, bank groups</td><td>800‚Äì4266 MHz</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="callout">
      <strong>From lecture:</strong> "With the Pentium era, clock speeds hit 133+ MHz. Asynchronous DRAM couldn't keep up ‚Äî the timing uncertainty was too great. SDRAM solved this by synchronizing operations to a clock, allowing burst transfers to match the CPU's 1-1-1-1 pipeline burst cycles."
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> 486 vs Pentium Burst Cycle Comparison</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Feature</th><th>80486</th><th>Pentium</th></tr></thead>
          <tbody>
            <tr><td>Bytes per cycle</td><td><strong>4 bytes</strong> (32-bit bus)</td><td><strong>8 bytes</strong> (64-bit bus)</td></tr>
            <tr><td>Total per burst</td><td>16 bytes</td><td>32 bytes</td></tr>
            <tr><td>Burst timing</td><td>2-1-1-1 (5 T-states)</td><td>2-1-1-1 (5 T-states)</td></tr>
            <tr><td>Address alignment</td><td>16-byte (XXXXXXX<strong>0</strong> ‚Äì XXXXXXX<strong>F</strong>)</td><td>32-byte (XXXXXXX<strong>00</strong> ‚Äì XXXXXXX<strong>1F</strong>)</td></tr>
            <tr><td>Burst order</td><td>0-4-8-C; 4-0-C-8; 8-C-0-4; C-8-4-0</td><td>0-8-10-18; 8-0-18-10; 10-18-0-8; 18-10-8-0</td></tr>
            <tr><td>Write burst</td><td><strong>NO</strong> ‚Äî can't burst in write mode</td><td><strong>YES</strong> ‚Äî can burst both read AND write</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> Pentium Pipelined Burst</h3>
      <p>The processor outputs the memory address for the <strong>NEXT</strong> cycle during the <strong>CURRENT</strong> cycle. This overlaps address and data phases, resulting in the ability to transfer bus-width of data per clock cycle ‚Äî including the initial startup cycle. Effective state timing: <strong>"1-1-1-1"</strong>.</p>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> SDRAM Burst Cycle Requirements (Pentium)</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>SRAM Type</th><th>33 MHz</th><th>50 MHz</th><th>66 MHz</th><th>100 MHz</th><th>125 MHz</th></tr></thead>
          <tbody>
            <tr><td><strong>Asynchronous</strong></td><td>2-1-1-1</td><td>3-2-2-2</td><td>3-2-2-2</td><td>3-2-2-2</td><td>3-2-2-2</td></tr>
            <tr><td><strong>Flow-Through Synchronous</strong></td><td>2-1-1-1</td><td>2-1-1-1</td><td>2-1-1-1</td><td>3-2-2-2</td><td>3-2-2-2</td></tr>
            <tr><td><strong>Pipelined Synchronous</strong></td><td>3-1-1-1</td><td>3-1-1-1</td><td>3-1-1-1</td><td>3-1-1-1</td><td>3-1-1-1</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> Data Transfer Rate Formula & Calculations</h3>
      <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent); margin:8px 0;">Data Transfer Rate = (# bytes transferred per access) / (Time for 1 bus cycle)</p>
      <p style="font-family:'IBM Plex Mono'; font-size:13px; color:var(--text-dim); margin:4px 0;">where 1 bus cycle = n √ó T<sub>clock</sub> (n = number of T-states)</p>
      <div class="table-wrap" style="margin-top:12px;">
        <table>
          <thead><tr><th>System</th><th>Calculation</th><th>Rate</th></tr></thead>
          <tbody>
            <tr><td><strong>XT (8088)</strong></td><td>1 byte √ó 4.77 MHz / 4 T-states</td><td><strong>1.19 MB/sec</strong></td></tr>
            <tr><td><strong>Pentium (non-burst)</strong></td><td>8 bytes √ó 66 MHz / 2 T-states</td><td><strong>264 MB/sec</strong></td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:12px;"><strong>SDRAM speed at 66 MHz (Pentium burst = 32 bytes per burst):</strong></p>
      <div class="table-wrap" style="margin-top:8px;">
        <table>
          <thead><tr><th>Mode</th><th>Clocks/Burst</th><th>Calculation</th><th>Bandwidth</th></tr></thead>
          <tbody>
            <tr><td>Asynch (3-2-2-2)</td><td>9</td><td>32 √ó 66M / 9</td><td><strong>234.7 MB/sec</strong></td></tr>
            <tr><td>Flow-Through (2-1-1-1)</td><td>5</td><td>32 √ó 66M / 5</td><td><strong>422.4 MB/sec</strong></td></tr>
            <tr><td>Pipelined (3-1-1-1)</td><td>6</td><td>32 √ó 66M / 6</td><td><strong>352 MB/sec</strong></td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> Memory Efficiency Comparison</h3>
      <p style="margin-bottom:8px;">Efficiency = (ideal CPU burst T-states) / (actual memory T-states). CPU ideal = 2-1-1-1 = <strong>5 T-states</strong>.</p>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Technology</th><th>Burst Timing</th><th>Total T-states</th><th>Efficiency</th></tr></thead>
          <tbody>
            <tr><td>CPU ideal</td><td>2-1-1-1</td><td>5</td><td>100%</td></tr>
            <tr><td><strong>SDRAM</strong></td><td>5-1-1-1</td><td>8</td><td><strong>63%</strong></td></tr>
            <tr><td><strong>EDO</strong></td><td>5-2-2-2</td><td>11</td><td><strong>45%</strong></td></tr>
            <tr><td><strong>FPM</strong></td><td>5-3-3-3</td><td>14</td><td><strong>35.7%</strong></td></tr>
            <tr><td>Non-FPM, Interleaved</td><td>5-5-5-5</td><td>20</td><td><strong>25%</strong></td></tr>
            <tr><td>Non-FPM, No Interleaving</td><td>8-8-8-8</td><td>32</td><td><strong>15.625%</strong></td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> Memory Interface Modules</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Module</th><th>Full Name</th><th>Pins</th><th>Data Width</th><th>Notes</th></tr></thead>
          <tbody>
            <tr><td><strong>SIMM</strong></td><td>Single In-line Memory Module</td><td>30 (1-byte) or 72 (4-byte)</td><td>8 or 32 bits</td><td>Contacts on one side only; 72-pin used for 486 systems</td></tr>
            <tr><td><strong>DIMM</strong></td><td>Dual In-line Memory Module</td><td>168</td><td>64 bits (8 bytes)</td><td>SIMMs with pins on both sides; used for Pentium+ systems</td></tr>
            <tr><td><strong>RIMM</strong></td><td>Rambus In-line Memory Module</td><td>184</td><td>16-bit @ 400 MHz</td><td>Serial data channel; <strong>all sockets must be populated</strong> (or use continuity module)</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Refresh Distribution Strategies</h3>
      <div class="kv-grid">
        <div class="kv">
          <div class="kv-label">Distributed Refresh</div>
          <div class="kv-value">Every <strong>15.625 ¬µs</strong>, a single refresh cycle is initiated. Minimal CPU interruption per event. Implemented on the XT using a periodic interrupt from the 8253 timer + a DMA channel to generate the refresh address.</div>
        </div>
        <div class="kv">
          <div class="kv-label">Burst Refresh</div>
          <div class="kv-value">Processor is forced into a wait state while <strong>all rows</strong> are refreshed in one burst. Longer single interruption, but no overhead between refreshes.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- REFERENCE SECTION              -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->


    <div class="card">
      <h3><span class="icon red">‚óÜ</span> Memory Bandwidth Evolution (from Feb 5 lecture)</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>CPU</th><th>Clock</th><th>T-state</th><th>States/MC</th><th>Access Time</th></tr></thead>
          <tbody>
            <tr><td>8088</td><td>4.77 MHz</td><td>209 ns</td><td>4 (√ó2.3 eff.)</td><td>~480 ns</td></tr>
            <tr><td>8086</td><td>10 MHz</td><td>100 ns</td><td>4 (√ó2.3 eff.)</td><td>~230 ns</td></tr>
            <tr><td>80386</td><td>33 MHz</td><td>30 ns</td><td>2 (√ó1.5 eff.)</td><td>~45 ns</td></tr>
            <tr><td>80486</td><td>50 MHz</td><td>20 ns</td><td>2 (√ó1.5 eff.)</td><td>~30 ns</td></tr>
            <tr><td>Pentium</td><td>66 MHz</td><td>15 ns</td><td>2 (√ó1.5 eff.)</td><td>~22.5 ns</td></tr>
            <tr><td>Pentium Pro, II</td><td>66 MHz</td><td>15 ns</td><td>2 (√ó1.5 eff.)</td><td>~22.5 ns</td></tr>
            <tr><td>Pentium II</td><td>100 MHz</td><td>10 ns</td><td>2 (√ó1.5 eff.)</td><td>~15 ns</td></tr>
            <tr><td>Pentium III</td><td>133 MHz</td><td>7.5 ns</td><td>2 (√ó1.5 eff.)</td><td><strong>~11.3 ns</strong></td></tr>
          </tbody>
        </table>
      </div>
      <p style="margin-top:8px;">Sir Clem (Feb 5): <em>"11.3 nanoseconds is just a little bit longer than the rise and fall time of a logic gate."</em> This is why asynchronous DRAM hit a wall.</p>
      <div class="callout tip" style="margin-top:12px;">
        <strong>Key architectural shift:</strong> 8088/8086 use a 4 T-state bus cycle (T1‚ÄìT4). From the 80386 onward, the bus cycle is only <strong>2 T-states</strong> (T1‚ÄìT2). At end of T2, if READY' is low, the CPU latches data. This explains the "1.5 effective states" for access time calculation.
      </div>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> The Data Window Problem</h3>
      <p>The <strong>data window</strong> = time that valid data is available for the CPU to latch. It equals:</p>
      <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent); margin:8px 0;">Data Window = tRC ‚àí tRAC ‚àí tRP</p>
      <p>As CPU speeds increase, tRC must shrink ‚Üí data window becomes dangerously short. If it's shorter than the logic settling time, the CPU reads garbage. This is the fundamental problem that drove all DRAM innovations.</p>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> Bank Interleaving</h3>
      <p>Uses <strong>two (or four) memory banks</strong> alternately. While Bank A is in its precharge period (tRP), Bank B is already serving the next address. This <strong>eliminates the precharge wait</strong> from the CPU's perspective.</p>
      <p>Limited performance gain since tRP is only a fraction of tRC, but it helps. Can scale to 4-bank interleaving for wider data buses.</p>
    </div>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> EDO DRAM: Internal Latch Solution</h3>
      <p>The key innovation: <strong>data output is latched internally</strong> so it persists even after CAS' is deasserted.</p>

      <!-- EDO vs FPM SVG -->
      <svg viewBox="0 0 700 200" style="width:100%; max-width:700px; margin:12px auto; display:block;">
        <style>
          .sig-sm { fill: #94a3b8; font-size: 10px; font-family: 'IBM Plex Mono', monospace; }
        </style>
        <!-- FPM side -->
        <text x="10" y="15" class="sig-sm" style="fill:#e2e8f0; font-size:12px;">FPM (Fast Page Mode)</text>
        <text x="10" y="40" class="sig-sm">CAS'</text>
        <polyline style="stroke:#06b6d4; stroke-width:1.5; fill:none;" points="50,30 50,48 120,48 120,30 160,30 160,48 230,48 230,30 330,30"/>
        <text x="10" y="70" class="sig-sm">Data</text>
        <polyline style="stroke:#e2e8f0; stroke-width:1.5; fill:none;" points="50,65 70,65"/>
        <rect x="70" y="55" width="40" height="18" fill="rgba(34,197,94,0.2)" stroke="#22c55e" stroke-width="1" rx="2"/>
        <text x="80" y="67" class="sig-sm" style="fill:#22c55e;">D0</text>
        <polyline style="stroke:#e2e8f0; stroke-width:1.5; fill:none;" points="110,65 140,65"/>
        <!-- Data disappears when CAS goes high -->
        <line x1="120" y1="55" x2="120" y2="78" class="dim-dash"/>
        <text x="125" y="85" class="sig-sm" style="fill:#ef4444; font-size:8px;">data gone!</text>
        <rect x="180" y="55" width="40" height="18" fill="rgba(34,197,94,0.2)" stroke="#22c55e" stroke-width="1" rx="2"/>
        <text x="190" y="67" class="sig-sm" style="fill:#22c55e;">D1</text>

        <!-- EDO side -->
        <text x="370" y="15" class="sig-sm" style="fill:#e2e8f0; font-size:12px;">EDO (Extended Data Out)</text>
        <text x="370" y="40" class="sig-sm">CAS'</text>
        <polyline style="stroke:#06b6d4; stroke-width:1.5; fill:none;" points="410,30 410,48 480,48 480,30 520,30 520,48 590,48 590,30 690,30"/>
        <text x="370" y="70" class="sig-sm">Data</text>
        <polyline style="stroke:#e2e8f0; stroke-width:1.5; fill:none;" points="410,65 430,65"/>
        <rect x="430" y="55" width="80" height="18" fill="rgba(34,197,94,0.2)" stroke="#22c55e" stroke-width="1.5" rx="2"/>
        <text x="460" y="67" class="sig-sm" style="fill:#22c55e;">D0</text>
        <!-- Data persists! -->
        <line x1="480" y1="55" x2="480" y2="78" class="dim-dash"/>
        <text x="485" y="85" class="sig-sm" style="fill:#22c55e; font-size:8px;">still valid!</text>
        <rect x="540" y="55" width="80" height="18" fill="rgba(34,197,94,0.2)" stroke="#22c55e" stroke-width="1.5" rx="2"/>
        <text x="570" y="67" class="sig-sm" style="fill:#22c55e;">D1</text>

        <!-- Data window comparison -->
        <line x1="70" y1="95" x2="110" y2="95" style="stroke:#ef4444; stroke-width:2;"/>
        <text x="50" y="108" class="sig-sm" style="fill:#ef4444;">small window</text>
        <line x1="430" y1="95" x2="530" y2="95" style="stroke:#22c55e; stroke-width:2;"/>
        <text x="440" y="108" class="sig-sm" style="fill:#22c55e;">LARGE window</text>
      </svg>

      <p>Cost: negligible (just an internal latch). Benefit: <strong>EDO effective up to ~66 MHz</strong> bus speed. Beyond that, asynchronous timing fails entirely.</p>
    </div>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> 486/Pentium Burst Cycle: 2-1-1-1 Pattern</h3>
      <p>For cache line fills, the CPU uses a <strong>burst cycle</strong>: first access takes 2 T-states, subsequent 3 accesses take 1 T-state each (only low-order address bits change).</p>

      <!-- Burst cycle SVG -->
      <svg viewBox="0 0 700 120" style="width:100%; max-width:700px; margin:12px auto; display:block;">
        <style>
          .burst-box { rx: 3; stroke-width: 1.5; }
        </style>
        <!-- T-states -->
        <rect x="50" y="15" width="120" height="40" class="burst-box" fill="rgba(59,130,246,0.15)" stroke="#3b82f6"/>
        <text x="110" y="40" class="state-txt" style="fill:#3b82f6;">2 T-states</text>
        <rect x="180" y="15" width="60" height="40" class="burst-box" fill="rgba(34,197,94,0.15)" stroke="#22c55e"/>
        <text x="210" y="40" class="state-txt" style="fill:#22c55e;">1T</text>
        <rect x="250" y="15" width="60" height="40" class="burst-box" fill="rgba(34,197,94,0.15)" stroke="#22c55e"/>
        <text x="280" y="40" class="state-txt" style="fill:#22c55e;">1T</text>
        <rect x="320" y="15" width="60" height="40" class="burst-box" fill="rgba(34,197,94,0.15)" stroke="#22c55e"/>
        <text x="350" y="40" class="state-txt" style="fill:#22c55e;">1T</text>

        <!-- Data labels -->
        <text x="110" y="73" class="phase-txt">xxx0h</text>
        <text x="210" y="73" class="phase-txt">xxx4h</text>
        <text x="280" y="73" class="phase-txt">xxx8h</text>
        <text x="350" y="73" class="phase-txt">xxxCh</text>

        <!-- Total -->
        <line x1="50" y1="90" x2="380" y2="90" style="stroke:#f59e0b; stroke-width:1;"/>
        <text x="420" y="40" class="phase-txt" style="fill:#f59e0b; font-size:11px;">= 5 T-states total</text>
        <text x="420" y="55" class="phase-txt" style="fill:#94a3b8;">486: 4√ó4 = 16 bytes</text>
        <text x="420" y="68" class="phase-txt" style="fill:#94a3b8;">Pentium: 4√ó8 = 32 bytes</text>
        <text x="420" y="83" class="phase-txt" style="fill:#94a3b8;">Pipeline: 1-1-1-1 (4T)</text>
      </svg>

      <p><strong>Address sequences</strong> (any starting point within 16-byte boundary): 0-4-8-C, 4-0-C-8, 8-C-0-4, or C-8-4-0. Pipeline burst overlaps next address with current data ‚Üí effective <strong>1-1-1-1</strong> pattern.</p>
    </div>

    <div class="callout warn">
      <strong>Why SDRAM was inevitable (Feb 5 lecture):</strong> EDO DRAM is asynchronous ‚Äî it relies on analog timing margins. Above 66 MHz, the uncertainty in when data appears becomes unacceptable (the whole data window is shorter than a gate's rise time). SDRAM adds a <strong>clock signal</strong> so all operations are edge-triggered and predictable. Commands are issued on rising edges; data appears on known future edges. This is what enables burst modes, mode registers, and the predictable 1-1-1-1 pattern at 100+ MHz.
    </div>

  </div>

  <div class="section" id="formulas">
    <span class="section-num">REF ¬∑ KEY FORMULAS</span>
    <h2>Timing & Calculation Reference</h2>

    <div class="card">
      <h3><span class="icon blue">‚óÜ</span> Clock Relationships (8284)</h3>
      <ul>
        <li><code>CLK = f_crystal √∑ 3</code> (33% duty cycle)</li>
        <li><code>PCLK = f_crystal √∑ 6</code> (50% duty cycle)</li>
        <li><code>T_state = 1 / f_CLK</code></li>
        <li>Bus cycle (no wait) = <code>4 √ó T_state</code></li>
        <li>Bus cycle (with wait) = <code>(4 + n_wait) √ó T_state</code></li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon amber">‚óÜ</span> Interrupt Vector Table</h3>
      <ul>
        <li>Vector address = <code>type_number √ó 4</code></li>
        <li>IP at: <code>type √ó 4</code> and <code>type √ó 4 + 1</code> (low byte first)</li>
        <li>CS at: <code>type √ó 4 + 2</code> and <code>type √ó 4 + 3</code></li>
        <li>Total IVT size: 256 √ó 4 = <code>1024 bytes = 1 KB</code></li>
        <li>IVT range: <code>00000h ‚Äì 003FFh</code></li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> Memory Timing Checks</h3>
      <ul>
        <li><strong>Read:</strong> Memory access time must be ‚â§ available address access time (from T1 to data valid point in T3, minus propagation delays)</li>
        <li><strong>Write:</strong> Data setup time must be met before WR' deactivates; data hold time after WR' deactivates must be satisfied</li>
        <li>Always account for: latch delays (74LS373), buffer delays (74LS245), decoder delays, and gate delays</li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon red">‚óÜ</span> DMA Timing Formulas</h3>
      <ul>
        <li><strong>DMA state time:</strong> <code>T_state = 1 / f_CLK</code> (e.g., 4 MHz ‚Üí 250 ns)</li>
        <li><strong>Full transfer:</strong> S1-S2-S3-S4 = <strong>4 states</strong> (used for first transfer + page boundary crosses)</li>
        <li><strong>Same-page transfer:</strong> S2-S3-S4 = <strong>3 states</strong> (most transfers when upper address unchanged)</li>
        <li><strong>Mem-to-mem:</strong> 4 states √ó 2 = <strong>8 states per byte</strong> (read source + write destination)</li>
        <li><strong>Block transfer time (worst case, boundary cross):</strong> <code>(2 √ó 4) + (N ‚àí 2) √ó 3</code> states</li>
        <li><strong>Block transfer time (best case, aligned):</strong> <code>4 + (N ‚àí 1) √ó 3</code> states</li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon cyan">‚óÜ</span> Memory Bandwidth & Efficiency Formulas</h3>
      <ul>
        <li><strong>Data transfer rate:</strong> <code>(bytes per access) / (time for 1 bus cycle)</code></li>
        <li>Or equivalently: <code>(bytes per access) √ó f_bus / (T-states per cycle)</code></li>
        <li><strong>XT example:</strong> 1 byte √ó 4.77 MHz / 4 = <strong>1.19 MB/s</strong></li>
        <li><strong>Pentium burst:</strong> 8 bytes √ó 66 MHz / 2 = <strong>264 MB/s</strong></li>
        <li><strong>SDRAM burst rate @ 66 MHz:</strong> <code>32 bytes / (N clocks √ó T_clk)</code></li>
        <li style="margin-top:8px;"><strong>Efficiency formula:</strong> <code>Ideal cycles / Actual cycles √ó 100%</code></li>
        <li>CPU ideal for 32-byte burst: <strong>2-1-1-1 = 5T</strong></li>
        <li>Example: SDRAM takes 8T ‚Üí efficiency = 5/8 = <strong>62.5%</strong></li>
      </ul>
    </div>

    <div class="card">
      <h3><span class="icon purple">‚óÜ</span> DDR Data Rate Formulas</h3>
      <ul>
        <li><strong>SDR:</strong> Data rate = Bus frequency (1 transfer/clock)</li>
        <li><strong>DDR:</strong> Data rate = Bus frequency √ó 2 (both edges). Also called MT/s (megatransfers/sec)</li>
        <li><strong>DDR prefetch relationship:</strong></li>
        <li>DDR: 2n prefetch ‚Üí <code>Data freq = 2 √ó Core freq</code></li>
        <li>DDR2: 4n prefetch ‚Üí <code>I/O freq = 2 √ó Core freq, Data freq = 2 √ó I/O freq = 4 √ó Core freq</code></li>
        <li>DDR3: 8n prefetch ‚Üí <code>Data freq = 8 √ó Core freq</code></li>
        <li><strong>PC/XT DRAM refresh interval:</strong> <code>t_refresh = 8 ms / rows</code> (e.g., 8 ms / 512 = 15.625 ¬µs)</li>
        <li><strong>8253 Timer Ch1 output (PC/XT):</strong> <code>1.19318 MHz / count = refresh rate</code></li>
      </ul>
    </div>
  </div>

  <div class="section" id="quickref">
    <span class="section-num">REF ¬∑ QUICK REFERENCE</span>
    <h2>Support Chip Quick Reference</h2>

    <div class="card">
      <div class="table-wrap">
        <table>
          <thead><tr><th>Chip</th><th>Type</th><th>Function</th></tr></thead>
          <tbody>
            <tr><td><code>8284</code></td><td>Clock Generator</td><td>CLK, PCLK, RESET, READY sync for 8086/88</td></tr>
            <tr><td><code>8259</code></td><td>PIC</td><td>Programmable Interrupt Controller ‚Äî 8 levels, cascadable</td></tr>
            <tr><td><code>8237</code></td><td>DMAC</td><td>DMA Controller ‚Äî 4 channels, 16-bit address, mem-to-mem</td></tr>
            <tr><td><code>8253/8254</code></td><td>PIT</td><td>Programmable Interval Timer ‚Äî 3 counter channels</td></tr>
            <tr><td><code>8255</code></td><td>PPI</td><td>Programmable Peripheral Interface ‚Äî parallel I/O</td></tr>
            <tr><td><code>8288</code></td><td>Bus Controller</td><td>Generates control bus signals in Maximum Mode</td></tr>
            <tr><td><code>74LS373</code></td><td>Octal Latch</td><td>Address latch ‚Äî transparent when LE high, latches on LE‚Üì</td></tr>
            <tr><td><code>74LS245</code></td><td>Bus Transceiver</td><td>Bidirectional data buffer ‚Äî direction via DIR, enable via E'</td></tr>
            <tr><td><code>74LS138</code></td><td>3-to-8 Decoder</td><td>Address decoder for chip select generation</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div style="margin-top:40px; padding:24px; background:var(--surface); border-radius:12px; border:1px solid var(--border); text-align:center;">
      <p style="color:var(--text-dim); font-size:13px;">CECNTRL T2 AY2025-26 ¬∑ Major Quiz 1 Reviewer</p>
      <p style="color:var(--text-dim); font-size:12px; margin-top:4px;">Based on compiled course modules and lecture transcripts (Jan 5 ‚Äì Feb 9, 2026)</p>
      <p style="color:var(--text-dim); font-size:11px; margin-top:4px;">Instructor: Clement Ong ¬∑ DLSU College of Computer Studies</p>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- STUDY GUIDE                                -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="section" id="coverage-audit">
    <span class="section-num">STUDY ¬∑ COVERAGE AUDIT</span>
    <h2>What's Covered & Where to Find It</h2>

    <p>This table maps every likely exam topic to where you can study it ‚Äî both in this reviewer and in the original source materials.</p>

    <div class="card">
      <h3><span class="icon green">‚úì</span> Coverage Checklist</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Topic</th><th>In This Reviewer?</th><th>Original Source</th><th>Priority</th></tr></thead>
          <tbody>
            <tr>
              <td>8086 vs 8088 differences</td>
              <td>‚úÖ Section 01</td>
              <td>compiled-modules.pdf pp.1‚Äì6</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>8086/8088 pin functions (all modes)</td>
              <td>‚úÖ Section 01.1</td>
              <td>compiled-modules.pdf pp.4‚Äì6</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>8284 clock gen ‚Äî frequency calcs</td>
              <td>‚úÖ Section 01.2</td>
              <td>compiled-modules.pdf pp.7‚Äì10</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>Bus demux ‚Äî 74LS373, 74LS245</td>
              <td>‚úÖ Section 01.3</td>
              <td>compiled-modules.pdf pp.11‚Äì12</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>Control line generation (MEMR/MEMW/IOR/IOW)</td>
              <td>‚úÖ Section 01.3</td>
              <td>compiled-modules.pdf p.12</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>8088 read/write timing diagrams</td>
              <td>‚úÖ Section 01.4</td>
              <td>compiled-modules.pdf pp.12‚Äì17; Jan 12 lecture</td>
              <td><span style="color:var(--red);">HIGH ‚Äî expect calculation</span></td>
            </tr>
            <tr>
              <td>Propagation delay in timing calcs</td>
              <td>‚úÖ Section 01.4 callout</td>
              <td>compiled-modules.pdf p.18; Jan 12 lecture (min 136‚Äì239)</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>8086 BHE'/A0 ‚Äî byte/word access</td>
              <td>‚úÖ Section 01.5</td>
              <td>compiled-modules.pdf pp.19‚Äì27</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>Memory alignment & performance</td>
              <td>‚úÖ Section 01.5</td>
              <td>compiled-modules.pdf pp.23‚Äì24; Jan 12 lecture</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>SRAM vs DRAM comparison</td>
              <td>‚úÖ Section 02</td>
              <td>compiled-modules.pdf pp.28‚Äì29</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>DRAM internal architecture (RAS/CAS)</td>
              <td>‚úÖ Section 02</td>
              <td>compiled-modules.pdf pp.29‚Äì32</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DRAM timing parameters (tRC, tRCD, etc.)</td>
              <td>‚úÖ Section 02.1</td>
              <td>compiled-modules.pdf pp.33‚Äì34</td>
              <td><span style="color:var(--red);">HIGH ‚Äî expect calculation</span></td>
            </tr>
            <tr>
              <td>DRAM refresh modes (RAS-only, CBR, Hidden)</td>
              <td>‚úÖ Section 02.2</td>
              <td>compiled-modules.pdf pp.35‚Äì37; Jan 19 lecture</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>Refresh strategies (burst vs distributed)</td>
              <td>‚úÖ Section 02.2</td>
              <td>Jan 19 lecture lines 82‚Äì176</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>DRAM page mode</td>
              <td>‚úÖ Section 02.3</td>
              <td>compiled-modules.pdf pp.38</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>8088/8086 interrupt system (vector table)</td>
              <td>‚úÖ Section 03</td>
              <td>compiled-modules.pdf pp.39‚Äì45</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>External interrupt sequence (INTR/INTA)</td>
              <td>‚úÖ Section 03</td>
              <td>compiled-modules.pdf pp.42‚Äì45</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>8259 PIC ‚Äî features, cascading</td>
              <td>‚úÖ Section 03.1</td>
              <td>compiled-modules.pdf pp.46‚Äì47</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>8237 DMA ‚Äî why, how, pins</td>
              <td>‚úÖ Section 04</td>
              <td>compiled-modules.pdf pp.48‚Äì54; Jan 26 lecture</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DMA operation sequence</td>
              <td>‚úÖ Section 04</td>
              <td>Jan 26 lecture</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>IBM PC/XT architecture (5150/5160, components)</td>
              <td>‚úÖ Section 05</td>
              <td>Feb 2 lecture; The_PC-XT_Architecture.pdf</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>PC/XT support chips (8253 PIT, 8255 PPI, 8259, 8237)</td>
              <td>‚úÖ Section 05</td>
              <td>The_PC-XT_Architecture.pdf pp.2‚Äì4</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>PC/XT expansion bus (62-pin ISA, signals)</td>
              <td>‚úÖ Section 05</td>
              <td>The_PC-XT_Architecture.pdf pp.5‚Äì6</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>PC/XT memory map (IVT, 640K, display buffer, BIOS)</td>
              <td>‚úÖ Section 05</td>
              <td>The_PC-XT_Architecture.pdf pp.7‚Äì8</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>PC/XT I/O map (system board + card slot addresses)</td>
              <td>‚úÖ Section 05</td>
              <td>The_PC-XT_Architecture.pdf pp.8‚Äì9</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>PC/XT DRAM refresh (8253 Ch1 ‚Üí DMA Ch0)</td>
              <td>‚úÖ Section 05</td>
              <td>The_PC-XT_Architecture.pdf p.10</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>Modern DRAM: FPM/EDO timing (tRAC, tCAC, tPC differences)</td>
              <td>‚úÖ Section 05.1</td>
              <td>Advanced_Memory_and_Processor_Access.pdf</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>SDRAM commands, read sequence, mode register</td>
              <td>‚úÖ Section 05.1</td>
              <td>Advanced_Memory_and_Processor_Access.pdf</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>486/Pentium burst cycles (2-1-1-1, pipeline burst)</td>
              <td>‚úÖ Section 05.1</td>
              <td>Advanced_Memory_and_Processor_Access.pdf</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>Memory bandwidth calculations & efficiency comparison</td>
              <td>‚úÖ Section 05.1 + Formulas</td>
              <td>Advanced_Memory_and_Processor_Access.pdf</td>
              <td><span style="color:var(--red);">HIGH ‚Äî expect calculation</span></td>
            </tr>
            <tr>
              <td>Memory modules (SIMM 30/72-pin, DIMM 168-pin, RIMM)</td>
              <td>‚úÖ Section 05.1</td>
              <td>Advanced_Memory_and_Processor_Access.pdf</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>DDR fundamentals (dual-edge, DQ, DQS strobe)</td>
              <td>‚úÖ Section 05.1</td>
              <td>DDR_Memory.pdf pp.1‚Äì2</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DDR2 (4n prefetch, 2√ó I/O clock, differential DQS, ODT, OCD)</td>
              <td>‚úÖ Section 05.1</td>
              <td>DDR_Memory.pdf pp.3‚Äì8</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DDR3 (8n prefetch, fly-by, write/read leveling, ZQ pin, 1.5V)</td>
              <td>‚úÖ Section 05.1</td>
              <td>DDR_Memory.pdf pp.8‚Äì14</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DDR4 (1.2V, 800‚Äì4266 MHz, 512 GiB/DIMM max)</td>
              <td>‚úÖ Section 05.1</td>
              <td>DDR_Memory.pdf p.15</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>DDR evolution table (prefetch, voltage, strobe, topology per gen)</td>
              <td>‚úÖ Section 05.1</td>
              <td>DDR_Memory.pdf (synthesis)</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>Divide-by-3 circuit design</td>
              <td>‚úÖ Practice D10</td>
              <td>Jan 8 lecture (Sir Clem: "quiz number one, problem one")</td>
              <td><span style="color:var(--red);">HIGH ‚Äî explicitly mentioned as quiz question</span></td>
            </tr>
            <tr>
              <td>50% duty cycle max frequency</td>
              <td>‚úÖ Practice D11 + Section 01.2</td>
              <td>Jan 8 lecture</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DMA transfer modes (single/block/demand)</td>
              <td>‚úÖ Section 04</td>
              <td>Jan 29 lecture; compiled-modules.pdf pp.49‚Äì51</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DMA transfer types (read/write/verify/mem-to-mem)</td>
              <td>‚úÖ Section 04</td>
              <td>Intel_DMAC_P2.pdf pp.1‚Äì3</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DMA register map (base/current addr, word count, mode, command, status)</td>
              <td>‚úÖ Section 04</td>
              <td>Intel_DMAC_P2.pdf pp.4‚Äì8</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DMA mem-to-mem (Ch0 source, Ch1 dest, 8 states, Temp Register)</td>
              <td>‚úÖ Section 04</td>
              <td>Intel_DMAC_P2.pdf pp.2‚Äì3</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>DMA First/Last flip-flop & register access addresses</td>
              <td>‚úÖ Section 04</td>
              <td>Intel_DMAC_P2.pdf pp.5‚Äì7</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>DMA cascading (master/slave HRQ/HLDA ‚Üî DREQ/DACK)</td>
              <td>‚úÖ Section 04</td>
              <td>Intel_DMAC_P2.pdf p.8</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>DMA timing states (S1-S4, S2-S4 optimization)</td>
              <td>‚úÖ Section 04 + Practice D8/D9</td>
              <td>Jan 29 lecture (in-class worked problem)</td>
              <td><span style="color:var(--red);">HIGH ‚Äî worked in class</span></td>
            </tr>
            <tr>
              <td>IO/M' vs M/IO' (8088 vs 8086 signal inversion)</td>
              <td>‚úÖ Section 01.3</td>
              <td>Jan 8 lecture; compiled-modules.pdf p.6</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>DEN'/DT/R' data buffer control</td>
              <td>‚úÖ Section 01.3</td>
              <td>Jan 8 lecture</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>Early write vs standard write (DRAM)</td>
              <td>‚úÖ Section 02.1</td>
              <td>Jan 15 lecture; compiled-modules.pdf pp.35‚Äì36</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>Memory bandwidth evolution (8088‚ÜíPentium)</td>
              <td>‚úÖ Section 05.1</td>
              <td>Feb 5 lecture</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>Data window problem / EDO vs FPM</td>
              <td>‚úÖ Section 05.1</td>
              <td>Feb 5 lecture</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>Burst cycle 2-1-1-1 / Pipeline burst</td>
              <td>‚úÖ Section 05.1</td>
              <td>Feb 5 lecture</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>Bank interleaving</td>
              <td>‚úÖ Section 05.1</td>
              <td>Feb 5 lecture</td>
              <td><span style="color:var(--amber);">MED</span></td>
            </tr>
            <tr>
              <td>Interrupt request circuit (74LS244 + D-FF)</td>
              <td>‚úÖ Practice D6</td>
              <td>Jan 22 lecture</td>
              <td><span style="color:var(--red);">HIGH</span></td>
            </tr>
            <tr>
              <td>ISA Bus basics</td>
              <td>‚ö†Ô∏è Brief mention</td>
              <td>Feb 2 lecture ‚Äî search for "ISA"</td>
              <td><span style="color:var(--text-dim);">LOW</span></td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="callout warn">
      <strong>Coverage note:</strong> This reviewer now covers all uploaded source PDFs comprehensively: compiled modules, DMA Part 2 (Intel_DMAC_P2), PC/XT Architecture, Advanced Memory & Processor Access, and DDR Memory (DDR1‚ÄìDDR4). The ISA bus is mentioned briefly ‚Äî know it was the 8-bit expansion bus of the PC/XT with a 62-pin connector running at 4.77 MHz.
    </div>
  </div>

  <!-- WHY IT MATTERS -->
  <div class="section" id="why-it-matters">
    <span class="section-num">STUDY ¬∑ CONCEPTUAL "WHY" DEEP DIVES</span>
    <h2>Why It Matters ‚Äî The Questions Behind the Facts</h2>

    <p>Sir Clem's lectures heavily emphasize the <em>reasoning</em> behind designs, not just memorization. These "why" explanations connect the dots and are likely identification/short-answer material.</p>

    <div class="card">
      <h3><span class="icon red">?</span> Why does the 8086/8088 need bus demultiplexing?</h3>
      <p><strong>Because address and data share the same physical pins</strong> (AD0‚ÄìAD7 on the 8088, AD0‚ÄìAD15 on the 8086). Intel did this to keep the pin count down on the chip package. The trade-off is that you need external latches (74LS373) triggered by ALE to capture the address during T1, so the pins are free to carry data during T2‚ÄìT4. Without demultiplexing, you'd lose the address the moment data appears on the bus.</p>
      <p><strong>Why include the "unnecessary" second latch for A8‚ÄìA15?</strong> Those pins are address-only and don't need latching ‚Äî but adding the latch provides: (1) symmetrical timing so all address lines arrive at memory simultaneously, and (2) additional current drive to support many memory/IO chips. From the Jan 12 lecture: "without some kind of buffering, the 8088 itself will not have enough capacity to push the required currents."</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does DRAM need refresh?</h3>
      <p><strong>Because DRAM stores bits as charge on tiny capacitors, and capacitors leak.</strong> Unlike SRAM (which uses a latch circuit with feedback that actively holds its state), a DRAM cell is just one transistor and one capacitor. The charge leaks through the transistor's junction and the capacitor's dielectric over time ‚Äî typically within milliseconds. If you don't periodically read and rewrite (refresh) each row, the charge drops below the detection threshold and data is lost.</p>
      <p><strong>Why only the row address?</strong> When RAS' activates, the entire row of cells connects to the sense amplifiers. The sense amps detect and amplify the tiny charges, then drive them back into the cells at full strength. This effectively "refreshes" every cell in that row simultaneously. So one RAS' pulse per row is all that's needed ‚Äî you don't need to address individual columns.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why is DMA faster than CPU-based data transfer?</h3>
      <p><strong>Three reasons:</strong></p>
      <p><strong>1. No instruction overhead.</strong> The CPU has to fetch, decode, and execute each instruction in a loop (LDAA, STAA, INX, INY, DECB, BNE = ~21 cycles per byte on HC11). The DMAC is a state machine ‚Äî it just drives address/data/control lines directly. One transfer = one bus cycle.</p>
      <p><strong>2. Simultaneous control signals.</strong> When the CPU does a memory-to-I/O copy, it must first read (MEMR' active) then write (IOW' active) ‚Äî two separate bus cycles. The DMAC can assert MEMR' and IOW' <em>at the same time</em>, so data flows directly from memory to the I/O device in a single cycle.</p>
      <p><strong>3. CPU is freed.</strong> While the DMAC handles the transfer, the CPU can resume processing (in block mode it waits, but in cycle-stealing mode it interleaves). From the Jan 26 lecture: "all that processing power just to MOVE data" ‚Äî DMA offloads the grunt work.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does page mode speed up DRAM access?</h3>
      <p><strong>Because it eliminates the row access overhead for sequential accesses within the same row.</strong> In a normal DRAM read cycle, the total time is tRC = tRAS + tRP (RAS active time + RAS precharge). The tRCD (RAS-to-CAS delay) plus the row decoding takes a large chunk of that. In page mode, the row stays open (RAS' stays low), and you only toggle CAS' for each column. The subsequent access time drops to roughly tCAS + tCP (CAS pulse + CAS precharge), which is significantly shorter than a full tRC cycle.</p>
      <p><strong>Analogy:</strong> It's like opening a filing cabinet drawer (row decode) once and then flipping through folders (columns) quickly, vs. closing and reopening the drawer for every single folder.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why did SDRAM replace asynchronous DRAM?</h3>
      <p><strong>Because asynchronous timing can't keep up at high clock frequencies.</strong> With the Pentium era pushing external bus clocks to 66‚Äì133 MHz, the timing margins for asynchronous DRAM became impossibly tight. Every timing parameter (tRCD, tCAS, tRP, etc.) had to be met with analog delay measurements ‚Äî at 133 MHz, a single clock period is only ~7.5 ns, leaving almost no margin for setup/hold violations.</p>
      <p>SDRAM locks everything to a clock edge. The controller issues a command on one rising edge, and data appears on a predictable future rising edge. This eliminates timing uncertainty and enables <strong>pipelined/burst access</strong> (the 1-1-1-1 pattern from the Feb 9 lecture) where the internal burst counter auto-increments the column address.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does DDR transfer on both clock edges?</h3>
      <p><strong>To double bandwidth without increasing clock frequency.</strong> Increasing the clock frequency is physically difficult ‚Äî higher frequencies mean more power consumption, more EMI, and tighter PCB layout requirements. DDR's insight is that the clock signal already has two transitions per cycle (rising and falling). By latching data on <em>both</em> edges, you get 2 data transfers per clock cycle. A 100 MHz DDR bus achieves 200 MT/s (megatransfers per second), matching the bandwidth of a hypothetical 200 MHz SDR bus at half the actual frequency.</p>
      <p><strong>How this scales:</strong> DDR2 doubles the prefetch buffer (4n), DDR3 doubles again (8n), DDR4 and DDR5 continue the pattern. Each generation also lowers voltage to reduce power.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does memory alignment matter on the 8086?</h3>
      <p><strong>Because the 8086 has a 16-bit data bus split into two 8-bit banks ‚Äî even and odd.</strong> When you access a 16-bit word from an even address, both banks are enabled simultaneously (BHE'=0, A0=0), and the entire word arrives in one bus cycle. But if the word starts at an odd address, the CPU must do <em>two</em> bus cycles: first read the odd byte from the upper bank, then read the even byte from the lower bank at the next address. This doubles the access time.</p>
      <p><strong>This principle scales:</strong> 32-bit CPUs (80386+) need 4-byte alignment, 64-bit CPUs need 8-byte alignment. The assembler's <code>PARA</code> directive forces paragraph (16-byte) alignment. Misalignment wastes performance on every access for the lifetime of the program.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does the PC/XT use DMA for DRAM refresh instead of just using the CPU?</h3>
      <p><strong>Because refresh must happen every 15.625 ¬µs, regardless of what the CPU is doing.</strong> If the CPU handled refresh, it would need to stop execution 64,000 times per second just to cycle through row addresses ‚Äî a huge waste of processing power. Instead, the PC/XT cleverly chains two existing chips: the <strong>8253 PIT Timer Channel 1</strong> fires every 15.625 ¬µs and triggers <strong>8237 DMA Channel 0</strong>. The DMA channel performs a "dummy read" ‚Äî it takes the bus briefly, drives an address (which cycles through refresh rows), and the DRAM sees the RAS' pulse as a refresh cycle. The CPU barely notices because each DMA cycle takes only ~4 clock cycles out of every ~75 available.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does the 8237 need a "First/Last Flip-Flop" for register access?</h3>
      <p><strong>Because 16-bit registers are accessed through an 8-bit data bus.</strong> The 8237's base address and word count registers are 16 bits wide, but the CPU's data bus connection to the DMAC is only 8 bits (D0‚ÄìD7). The flip-flop tracks whether the next byte written/read is the <em>low byte</em> (first) or <em>high byte</em> (last). Two consecutive I/O writes to the same register address load the full 16-bit value. The flip-flop must be explicitly cleared (via the Clear First/Last FF command) before any multi-byte register access to ensure synchronization.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does DDR2 run its I/O buffer at 2√ó the core frequency?</h3>
      <p><strong>Because DDR already uses both clock edges, so there are no more edges to exploit at the core clock rate.</strong> DDR1 gets 2 transfers per clock by using rising and falling edges. To double bandwidth again, DDR2 prefetches 4 bits from the core at once. But the I/O buffer, running at the core clock rate, can only output 2 bits per clock (one per edge). The solution: run the I/O buffer at 2√ó the core frequency, giving 4 edges per core clock cycle ‚Äî exactly enough to pump out the 4 prefetched bits. The memory core itself stays at the same speed (it's physically hard to speed up the DRAM array); only the external interface runs faster.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does DDR3 use fly-by topology instead of the T-topology of DDR2?</h3>
      <p><strong>To reduce Simultaneous Switching Noise (SSN).</strong> In DDR2's T (star) topology, command/address/clock signals split and reach all DRAM chips simultaneously. At high frequencies, all chips switching at the same instant creates massive current spikes (SSN), causing voltage droops and timing errors. DDR3's fly-by topology routes signals past each chip <em>in series</em>, so they arrive at staggered times ‚Äî spreading the switching current over time. The trade-off is that each chip now sees the command at a different delay. This is solved by <strong>write leveling</strong> (the memory controller calibrates a per-chip DQS launch delay) and <strong>read leveling</strong> (IODELAY elements with 75ps taps compensate for per-bit skew).</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why do DDR3 latency numbers appear "worse" than DDR2 but aren't?</h3>
      <p><strong>Because latency is measured in clock cycles, and DDR3's clock cycles are shorter.</strong> DDR2 typical latencies: 5-5-5-15 at ~400 MHz I/O clock ‚Üí CAS latency = 5 / 400 MHz = 12.5 ns. DDR3 typical latencies: 7-7-7-20 at ~667 MHz I/O clock ‚Üí CAS latency = 7 / 667 MHz = 10.5 ns. The DDR3 number is <em>higher</em> in clock ticks but <em>lower</em> in absolute time (~10 ns vs ~12.5 ns). This is a common exam trick question ‚Äî always convert to nanoseconds for a fair comparison.</p>
    </div>

    <div class="card">
      <h3><span class="icon red">?</span> Why does the 8259 PIC exist instead of just wiring devices to INTR?</h3>
      <p><strong>Because the 8088 only has ONE maskable interrupt input pin (INTR).</strong> If you have multiple devices that need to interrupt, you need something to manage priority, identify which device interrupted, and provide the type number. Without the 8259, you'd have to build your own priority encoder, type-number generator, and masking logic from discrete components. The 8259 does all of this in one chip: it accepts 8 interrupt inputs, resolves priority, masks as programmed, and outputs the correct type number during the INTA' cycle. Cascading allows up to 64 sources.</p>
    </div>
  </div>

  <!-- STUDY STRATEGY -->
  <div class="section" id="study-strategy">
    <span class="section-num">STUDY ¬∑ HOW TO REVIEW</span>
    <h2>Study Strategy & Time Allocation</h2>

    <div class="card">
      <h3><span class="icon green">‚óÜ</span> Recommended Study Order (10‚Äì12 hours total)</h3>

      <div class="subsection">
        <h3>Phase 1: Concepts First (3‚Äì4 hours)</h3>
        <p>Read through the <a href="#why-it-matters" style="color:var(--accent);">Why It Matters</a> section above. For each "why," make sure you can explain it in your own words without looking. This covers the identification section of the exam (~30-40% of grade) and is the highest return on study time.</p>
        <p><strong>Source materials:</strong></p>
        <ul>
          <li>This reviewer ‚Äî Sections 01 through 05.1 (skim for concepts)</li>
          <li>The <a href="#quickref" style="color:var(--accent);">Quick Reference table</a> ‚Äî memorize what each chip does</li>
          <li>DDR evolution: know the prefetch, voltage, and key innovation for each generation</li>
          <li>PC/XT: know which chip is at which I/O address, and the memory map boundaries</li>
          <li>DMA: know transfer types (read/write/verify/mem-to-mem) and control signals for each</li>
        </ul>
      </div>

      <div class="subsection">
        <h3>Phase 2: Timing & Bandwidth Calculations (3‚Äì4 hours)</h3>
        <p>This is the hardest part and where most points are lost. Work through the practice problems below, then do them again without looking at the solutions.</p>
        <p><strong>Source materials:</strong></p>
        <ul>
          <li>compiled-modules.pdf pages 12‚Äì17 ‚Äî the 8088 read/write timing diagrams with parameter labels</li>
          <li>compiled-modules.pdf pages 33‚Äì34 ‚Äî DRAM read/write timing diagrams</li>
          <li>Jan 12 lecture transcript lines 136‚Äì239 ‚Äî Sir Clem walks through timing parameter derivation step by step (this is gold for the exam)</li>
          <li>The <a href="#formulas" style="color:var(--accent);">Key Formulas</a> section ‚Äî now includes bandwidth, efficiency, DDR data rate, and DMA timing formulas</li>
          <li><strong>NEW:</strong> Memory bandwidth calculations ‚Äî know how to compute transfer rate for XT through Pentium, and SDRAM efficiency at different access modes (async, flow-through, pipelined)</li>
        </ul>
        <p><strong>Key skill:</strong> Given a timing diagram and a datasheet, compute whether a memory chip is fast enough for the system. Always remember: <mark>available time = gross time from timing diagram ‚àí latch delay ‚àí buffer delay ‚àí gate delay</mark></p>
      </div>

      <div class="subsection">
        <h3>Phase 3: Design, Tracing & DDR Concepts (3‚Äì4 hours)</h3>
        <p>Practice tracing through the interrupt sequence, DMA sequence, and 8086 byte/word access scenarios. Draw the block diagrams from memory. For DDR, focus on understanding the architecture diagrams and why each generation's innovations were needed.</p>
        <p><strong>Source materials:</strong></p>
        <ul>
          <li>compiled-modules.pdf page 15 ‚Äî the full 8088 minimum mode schematic (try to redraw from memory)</li>
          <li>compiled-modules.pdf pages 42‚Äì45 ‚Äî external interrupt sequence with circuit example</li>
          <li>compiled-modules.pdf page 54 ‚Äî 8088 with DMA system diagram</li>
          <li>Jan 26 lecture transcript ‚Äî DMA walkthrough</li>
          <li><strong>NEW:</strong> DMA register map and access addresses (Section 04) ‚Äî know how to program the 8237</li>
          <li><strong>NEW:</strong> DDR_Memory.pdf ‚Äî the SDRAM/DDR/DDR2 architecture diagram (core freq vs I/O freq vs data freq)</li>
          <li><strong>NEW:</strong> DDR3 fly-by vs T topology, write leveling, read leveling concepts</li>
        </ul>
      </div>
    </div>

    <div class="callout tip">
      <strong>Sir Clem's style (from observing transcripts):</strong> He likes to ask "what happens when..." scenario questions. Practice explaining sequences step-by-step: what happens when an interrupt fires? What happens when a DMA transfer is requested? What happens when the 8086 executes <code>MOV AX, [2001h]</code>? What's the difference between DDR2 and DDR3? If you can narrate these in order, you're well prepared.
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- PRACTICE EXAM                              -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->

  <div class="section" id="practice-ident">
    <span class="section-num">PRACTICE ¬∑ IDENTIFICATION & SHORT ANSWER</span>
    <h2>Practice Problems: Identification</h2>

    <p>These simulate the ~30-40% identification section. Try answering before revealing the solutions.</p>

    <div class="card">
      <h3><span class="icon blue">Q1</span> What is the purpose of the ALE signal on the 8088? <a href="#bus-demux" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.3 Bus Demux</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p><strong>ALE (Address Latch Enable)</strong> indicates that the address/data bus currently contains a valid address (during T1). It is connected to the LE (Latch Enable) input of 74LS373 octal latches. When ALE goes high, the latches become transparent (address passes through). When ALE falls, the address is latched and held stable for the rest of the bus cycle, freeing the AD pins to carry data in T2‚ÄìT4.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q2</span> What are the four control bus signals generated from the 8088, and how are they derived? <a href="#bus-demux" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.3 Bus Demux</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p>The 8088 outputs <code>RD'</code>, <code>WR'</code>, and <code>IO/M'</code>. These are combined with logic gates to produce:</p>
          <ul>
            <li><code>MEMR'</code> = NOT(IO/M') AND RD' ‚Äî memory read (IO/M' low means memory)</li>
            <li><code>MEMW'</code> = NOT(IO/M') AND WR' ‚Äî memory write</li>
            <li><code>IOR'</code> = IO/M' AND RD' ‚Äî I/O read (IO/M' high means I/O)</li>
            <li><code>IOW'</code> = IO/M' AND WR' ‚Äî I/O write</li>
          </ul>
          <p>Note: On the 8086, the pin is <code>M/IO'</code> (inverted sense), so the logic differs.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q3</span> What is the difference between RAS-only refresh and CAS-before-RAS refresh? <a href="#dram-refresh" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß02.2 Refresh</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p><strong>RAS-only:</strong> An external circuit (e.g., a counter driven by the DMA controller or a dedicated refresh controller) provides the row address on the address pins, then pulses RAS' while keeping CAS' inactive. The DRAM refreshes the specified row. Requires an external row address counter.</p>
          <p><strong>CAS-before-RAS (CBR):</strong> CAS' is asserted <em>before</em> RAS'. This is an abnormal sequence that the DRAM recognizes as a refresh command. The DRAM uses its own <em>internal</em> row counter to determine which row to refresh. No external counter is needed ‚Äî the DRAM self-manages the refresh row sequence.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q4</span> Why can the 8237 DMAC transfer data faster than the CPU for block data movement? <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p>The DMAC is a state machine, not a program-executing processor. It doesn't need to fetch/decode instructions. More critically, during an I/O-to-memory or memory-to-I/O transfer, it can activate both the memory and I/O control signals <strong>simultaneously</strong> (e.g., <code>IOR'</code> and <code>MEMW'</code> at the same time). Data flows directly from the source to the destination in one bus cycle. The CPU would require two separate bus cycles ‚Äî one to read and one to write ‚Äî plus loop overhead (increment address, decrement counter, branch).</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q5</span> What is the role of BHE' and A0 in the 8086 memory system? <a href="#8086-databus" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.5 Data Bus</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p>The 8086's 16-bit data bus is organized as two 8-bit memory banks: an <strong>even bank</strong> (D0‚ÄìD7, selected by A0=0) and an <strong>odd bank</strong> (D8‚ÄìD15, selected by BHE'=0). Together they encode four access types:</p>
          <ul>
            <li>BHE'=0, A0=0 ‚Üí both banks active ‚Üí 16-bit word from even address</li>
            <li>BHE'=0, A0=1 ‚Üí odd bank only ‚Üí 8-bit byte from odd address</li>
            <li>BHE'=1, A0=0 ‚Üí even bank only ‚Üí 8-bit byte from even address</li>
            <li>BHE'=1, A0=1 ‚Üí no action</li>
          </ul>
          <p>A 16-bit access from an odd address requires <em>two bus cycles</em> because both banks can't be accessed with the same row of addresses ‚Äî a performance penalty avoided through alignment.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q6</span> What is the CLK frequency and PCLK frequency if the 8284 is driven by a 14.318 MHz crystal? <a href="#8284-clock" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.2 Clock Gen</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p>CLK = 14.318 MHz √∑ 3 = <strong>4.773 MHz</strong> (33% duty cycle) ‚Äî this goes to the 8088 CPU.</p>
          <p>PCLK = 14.318 MHz √∑ 6 = <strong>2.386 MHz</strong> (50% duty cycle) ‚Äî this goes to peripheral devices like the 8253 PIT.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q7</span> What is the Interrupt Vector Table? How is it organized? <a href="#interrupts" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß03 Interrupts</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p>The IVT is a table of 256 entries stored in the first 1 KB of memory (00000h‚Äì003FFh). Each entry is 4 bytes: the first 2 bytes are the IP (offset) of the ISR, and the next 2 bytes are the CS (segment) of the ISR. The vector table address for type N is calculated as N √ó 4. For example, type 2 (NMI) has its vector at address 0008h (2 √ó 4 = 8).</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q8</span> What problem did SDRAM solve over EDO/FPM DRAM? What key feature does it introduce? <a href="#modern-dram" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05.1 Modern DRAM</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p>Asynchronous DRAM (FPM/EDO) could not reliably meet timing requirements at bus speeds above ~66 MHz due to timing uncertainty. SDRAM solves this by <strong>synchronizing all operations to a clock signal</strong>. Commands are issued on one clock rising edge and data appears on a predictable future edge. It also introduces an <strong>internal burst counter</strong> and <strong>mode registers</strong> that allow configuring burst length, CAS latency, and other parameters at initialization. This enables pipelined burst access patterns (1-1-1-1 cycles) matching the CPU's cache-line fill requirements.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q9</span> Describe the sequence of events when an external device interrupts the 8088 via INTR. <a href="#interrupts" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß03 Interrupts</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <ol>
            <li>The device asserts the INTR pin (held high).</li>
            <li>The CPU checks INTR at the end of each instruction. If IF (Interrupt Flag) = 1, it acknowledges.</li>
            <li>The CPU sends the <strong>first INTA' pulse</strong> ‚Äî this signals the device to prepare its type number. The LOCK signal is also asserted to prevent bus arbitration.</li>
            <li>The CPU sends the <strong>second INTA' pulse</strong> ‚Äî the device (or 8259 PIC) places the 8-bit interrupt type number on D0‚ÄìD7.</li>
            <li>The CPU reads the type number, computes the vector table address (type √ó 4), pushes FLAGS, CS, and IP onto the stack, clears IF and TF, then loads CS:IP from the vector table ‚Äî branching to the ISR.</li>
            <li>The ISR executes and ends with IRET, which pops IP, CS, and FLAGS from the stack, returning to the interrupted program.</li>
          </ol>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q10</span> What is the role of DREQ, DACK, HRQ, and HLDA in the 8237 DMA system? <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <ul>
            <li><strong>DREQ (DMA Request):</strong> Input from a peripheral device requesting DMA service. There are 4 channels (DREQ0‚Äì3), with DREQ0 having highest default priority.</li>
            <li><strong>HRQ (Hold Request):</strong> Output from the 8237 to the CPU's HOLD pin, requesting the CPU to release the bus.</li>
            <li><strong>HLDA (Hold Acknowledge):</strong> Input from the CPU's HLDA pin, telling the 8237 that the CPU has tri-stated its buses and the DMAC can take control.</li>
            <li><strong>DACK (DMA Acknowledge):</strong> Output to the specific peripheral that requested the transfer, telling it that its DMA channel is active and it should participate in the data transfer (read or write).</li>
          </ul>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q11</span> In the 8237 DMA controller, what are the four transfer types, and which control signals are active for each? <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <ul>
            <li><strong>Read transfer (memory ‚Üí I/O):</strong> MEMR' and IOW' active simultaneously. Data flows from memory to the peripheral.</li>
            <li><strong>Write transfer (I/O ‚Üí memory):</strong> IOR' and MEMW' active simultaneously. Data flows from the peripheral to memory.</li>
            <li><strong>Verify transfer:</strong> No memory or I/O signals are activated. The DMAC goes through the motions (address generation, counting) but no data is actually transferred. Used to test/verify the DMA logic.</li>
            <li><strong>Memory-to-memory:</strong> Ch0 = source address, Ch1 = destination address. Uses the internal Temporary Register. Requires 2 bus cycles per byte (8 DMA states): first reads from Ch0 address into Temp Register (MEMR'), then writes from Temp Register to Ch1 address (MEMW').</li>
          </ul>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q12</span> What is the purpose of the First/Last Flip-Flop in the 8237 DMA controller? <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p>The 8237's 16-bit registers (Base Address, Base Word Count, Current Address, Current Word Count) must be accessed through an 8-bit data bus. The <strong>First/Last Flip-Flop (F/L FF)</strong> tracks whether the next byte operation targets the <strong>low byte (first)</strong> or <strong>high byte (last)</strong>. Two consecutive writes to the same register address load the complete 16-bit value. The flip-flop toggles after each byte access. It must be explicitly cleared (via the Clear F/L FF command at a specific I/O address) before programming any multi-byte register to ensure the low byte is written first.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q13</span> In the IBM PC/XT, how is DRAM refresh implemented? Which chips are involved? <a href="#pc-arch" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05 PC/XT</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p>The PC/XT uses <strong>distributed refresh</strong> via a chain of two chips:</p>
          <ol>
            <li>The <strong>8253 PIT Timer Channel 1</strong> is programmed to generate an output pulse every <strong>15.625 ¬µs</strong> (using the 1.19318 MHz PCLK input).</li>
            <li>This pulse triggers <strong>8237 DMA Channel 0</strong> via DREQ0.</li>
            <li>The DMA controller performs a "dummy read" ‚Äî it takes the bus, outputs an address, but the data read is discarded.</li>
            <li>The act of the DMA driving an address on the bus activates RAS' on the DRAM, which refreshes the addressed row.</li>
            <li>The DMA address auto-increments, cycling through all 256 (or 512) rows within the 8 ms refresh window.</li>
          </ol>
          <p>This uses almost no CPU time (~1.3% overhead) and requires no software involvement.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q14</span> Name the five key support chips in the IBM PC/XT and state each one's function and I/O address range. <a href="#pc-arch" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05 PC/XT</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <ol>
            <li><strong>8237 DMAC</strong> (0000h‚Äì000Fh): 4-channel DMA controller. Ch0 = DRAM refresh, Ch1‚Äì3 for peripherals.</li>
            <li><strong>8259 PIC</strong> (0020h‚Äì0021h): 8-level interrupt controller. IRQ0 = timer, IRQ1 = keyboard, IRQ6 = floppy.</li>
            <li><strong>8253 PIT</strong> (0040h‚Äì0043h): 3-channel timer. Ch0 = system clock (IRQ0 tick), Ch1 = DRAM refresh trigger, Ch2 = speaker tone.</li>
            <li><strong>8255 PPI</strong> (0060h‚Äì0063h): Parallel I/O. Port A = keyboard data, Port B = speaker/cassette/switch control, Port C = switch readings.</li>
            <li><strong>8288 Bus Controller</strong>: Generates bus control signals (MEMR', MEMW', IOR', IOW', ALE, DEN, DT/R') from the 8088's status lines in maximum mode. Not I/O-mapped (directly wired to CPU).</li>
          </ol>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q15</span> What is the fundamental difference between SDR SDRAM and DDR SDRAM? How does DDR2 differ from DDR? <a href="#modern-dram" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05.1 Modern DRAM</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p><strong>SDR vs DDR:</strong> SDR SDRAM transfers data on only the <strong>rising edge</strong> of the clock. DDR transfers on <strong>both rising and falling edges</strong>, doubling the data rate at the same clock frequency. DDR uses a 2-bit prefetch ‚Äî 2 bits from the core go to the I/O buffer, which releases one bit per clock edge. The core and I/O run at the same frequency.</p>
          <p style="margin-top:8px;"><strong>DDR vs DDR2:</strong> DDR2 increases the prefetch to <strong>4 bits</strong>. Since both edges are already used, the I/O buffer must run at <strong>2√ó the core frequency</strong> to pump out all 4 bits. DDR2 also drops voltage from 2.5V to <strong>1.8V</strong>, introduces <strong>differential DQS</strong> (DQS + /DQS) for better signal integrity, and adds <strong>On-Die Termination (ODT)</strong> ‚Äî building termination resistors directly into the memory chip for better reflection absorption.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q16</span> What are the key innovations of DDR3 over DDR2? Why does DDR3 need write leveling? <a href="#modern-dram" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05.1 Modern DRAM</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <p><strong>Key DDR3 innovations:</strong></p>
          <ul>
            <li><strong>8n prefetch</strong> (double DDR2's 4n) for higher bandwidth</li>
            <li><strong>1.5V</strong> operation (down from DDR2's 1.8V)</li>
            <li><strong>Fly-by topology</strong> instead of T/star ‚Äî reduces SSN (simultaneous switching noise)</li>
            <li><strong>ZQ pin</strong> for built-in impedance calibration (DDR2 used off-chip OCD)</li>
            <li><strong>Write leveling and read leveling</strong> for timing compensation</li>
          </ul>
          <p style="margin-top:8px;"><strong>Why write leveling?</strong> Fly-by topology routes signals in series past each chip, so each chip sees the clock/command at a different delay. The memory controller must <strong>calibrate a per-chip DQS launch delay</strong> to compensate. Without write leveling, a write command would arrive at different chips at different times relative to their DQS, causing data corruption.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon blue">Q17</span> What is the PC/XT memory map? Identify the address ranges for RAM, display buffer, and BIOS. <a href="#pc-arch" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05 PC/XT</a></h3>
      <details style="margin-top:8px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:12px; background:var(--surface2); border-radius:8px;">
          <ul>
            <li><strong>00000h‚Äì003FFh:</strong> Interrupt Vector Table (1 KB, 256 entries √ó 4 bytes)</li>
            <li><strong>00400h‚Äì9FFFFh:</strong> Conventional RAM (up to 640 KB)</li>
            <li><strong>A0000h‚ÄìBFFFFh:</strong> Display buffer (128 KB reserved). Monochrome text: B0000h‚ÄìB7FFFh (4 KB used). CGA: B8000h‚ÄìBCFFFh (16 KB used).</li>
            <li><strong>C0000h‚ÄìEFFFFh:</strong> ROM expansion area (192 KB) ‚Äî for add-on card BIOSes</li>
            <li><strong>F0000h‚ÄìFFFFFh:</strong> System BIOS + BASIC ROM (64 KB). CPU starts at FFFF0h on reset.</li>
          </ul>
          <p>This gives the famous <strong>640 KB conventional memory limit</strong> (A0000h = 640 √ó 1024).</p>
        </div>
      </details>
    </div>
  </div>

  <!-- TIMING PRACTICE PROBLEMS -->
  <div class="section" id="practice-timing">
    <span class="section-num">PRACTICE ¬∑ TIMING CALCULATIONS</span>
    <h2>Practice Problems: Timing</h2>

    <div class="card">
      <h3><span class="icon amber">T1</span> 8088 Read Cycle ‚Äî Memory Access Time Calculation <a href="#timing" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.4 Timing</a></h3>
      <p><strong>Given:</strong></p>
      <ul>
        <li>8088 running at 4.77 MHz (T_state = 1/4.77 MHz = 209.6 ns)</li>
        <li>74LS373 latch propagation delay = 12 ns</li>
        <li>74LS245 buffer propagation delay = 12 ns</li>
        <li>Data setup time before CLK rising edge of T4 = 30 ns (from 8088 datasheet)</li>
        <li>No wait states</li>
      </ul>
      <p><strong>Question:</strong> What is the maximum allowable memory access time (address valid to data valid)?</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Step 1: Determine the total available time from address out to data needed.</strong></p>
          <p>Address becomes valid partway through T1 (after ALE latches it). Data must be valid before the rising edge of T4 minus the data setup time.</p>
          <p>Available gross time ‚âà from middle of T1 to end of T3 = approximately <strong>3 T-states</strong> (T1 half + T2 + T3 half) ‚Äî but let's use the more precise approach:</p>
          <p>The address is latched on the falling edge of ALE, which occurs near the end of T1. Data is sampled at the rising edge of T4 (= end of T3).</p>
          <p>Gross time from address latch to data sample ‚âà <strong>3 √ó 209.6 ns = 628.8 ns</strong> (approximately ‚Äî the exact value depends on specific timing parameters from the datasheet, but this is the exam-level approximation).</p>

          <p><strong>Step 2: Subtract propagation delays.</strong></p>
          <ul>
            <li>74LS373 latch delay (address path): <strong>‚àí12 ns</strong></li>
            <li>74LS245 buffer delay (data path): <strong>‚àí12 ns</strong></li>
            <li>Data setup time: <strong>‚àí30 ns</strong></li>
          </ul>

          <p><strong>Step 3: Maximum allowable memory access time:</strong></p>
          <p style="font-family:'IBM Plex Mono'; font-size:15px; color:var(--accent);">
            t_access = 628.8 ‚àí 12 ‚àí 12 ‚àí 30 = <strong>574.8 ns</strong>
          </p>
          <p>So the memory chip must have an access time ‚â§ ~575 ns ‚Äî easily met by most SRAMs of the era (e.g., 2764 EPROM at 450 ns, 6264 SRAM at 150 ns).</p>

          <div class="callout warn" style="margin-top:12px;">
            <strong>Note:</strong> The exact numbers depend on which specific timing parameters your exam provides from the 8088 datasheet (TCLAV, TDVCL, etc.). The methodology is always the same: gross time available minus all delays in the signal path. If control line generation uses gates, include those gate delays too.
          </div>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon amber">T2</span> Wait State Calculation <a href="#timing" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.4 Timing</a></h3>
      <p><strong>Given:</strong></p>
      <ul>
        <li>8088 at 5 MHz (T_state = 200 ns)</li>
        <li>Memory access time = 350 ns</li>
        <li>Address latch delay = 15 ns</li>
        <li>Data buffer delay = 15 ns</li>
        <li>Data setup time = 30 ns</li>
        <li>Available time with 0 wait states (address valid to data sample) = 2.5 T-states = 500 ns</li>
      </ul>
      <p><strong>Question:</strong> How many wait states are needed?</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Step 1: Available time with 0 wait states:</strong></p>
          <p>Available = 500 ‚àí 15 (latch) ‚àí 15 (buffer) ‚àí 30 (setup) = <strong>440 ns</strong></p>

          <p><strong>Step 2: Compare to memory access time:</strong></p>
          <p>Memory needs 350 ns. Available is 440 ns. Since 350 < 440, <strong>0 wait states are needed</strong>.</p>

          <p><strong>But what if the memory was 500 ns?</strong></p>
          <p>Available with 0 waits = 440 ns. Not enough (500 > 440).</p>
          <p>Each wait state adds 1 T-state = 200 ns.</p>
          <p>Available with 1 wait state = 440 + 200 = 640 ns. Since 500 < 640, <strong>1 wait state is sufficient</strong>.</p>

          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent); margin-top:12px;">
            Formula: n_wait = ‚åà(t_access ‚àí t_available_0wait) / T_state‚åâ<br>
            n_wait = ‚åà(500 ‚àí 440) / 200‚åâ = ‚åà60/200‚åâ = ‚åà0.3‚åâ = <strong>1 wait state</strong>
          </p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon amber">T3</span> DRAM Compatibility Check <a href="#dram-timing" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß02.1 DRAM Timing</a></h3>
      <p><strong>Given:</strong></p>
      <ul>
        <li>A DRAM chip with tRC (read cycle time) = 250 ns</li>
        <li>An 8088 system at 4.77 MHz with 1 wait state</li>
        <li>T_state = 209.6 ns</li>
      </ul>
      <p><strong>Question:</strong> Is this DRAM fast enough for the system?</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Step 1: Calculate bus cycle time.</strong></p>
          <p>With 1 wait state: bus cycle = (4 + 1) √ó 209.6 ns = <strong>1048 ns</strong></p>

          <p><strong>Step 2: Compare.</strong></p>
          <p>The DRAM's tRC = 250 ns, and the bus cycle provides 1048 ns. Since 250 << 1048, this DRAM is <strong>more than fast enough</strong>.</p>

          <p><strong>The real question in practice</strong> is whether the RAS/CAS timing within the bus cycle can be met ‚Äî you'd need to check tRAS, tRCD, tCAS, tRP individually against the control signals provided by the DRAM controller. But for the exam, the tRC vs. bus cycle time comparison is the primary check.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon amber">T4</span> CPU vs DMA Transfer Time Comparison <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <p><strong>Given (from compiled-modules.pdf p.49, HC11 example):</strong></p>
      <ul>
        <li>HC11 CPU doing a 256-byte memory-to-memory copy using a loop</li>
        <li>Loop body: LDAA 0,X (4 cycles) + STAA 0,Y (5 cycles) + INX (3 cycles) + INY (4 cycles) + DECB (2 cycles) + BNE (3 cycles) = 21 cycles per byte</li>
        <li>Setup: LDX (3) + LDY (4) + LDAB (2) = 9 cycles</li>
        <li>CPU clock = 2 MHz (T_state = 500 ns)</li>
        <li>DMA: 1 bus cycle per byte transfer</li>
      </ul>
      <p><strong>Question:</strong> Calculate total time for CPU method vs. DMA method.</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>CPU method:</strong></p>
          <p>Total cycles = 9 (setup) + 256 √ó 21 (loop) = 9 + 5376 = <strong>5385 cycles</strong></p>
          <p>Total time = 5385 √ó 500 ns = <strong>2,692,500 ns ‚âà 2.69 ms</strong></p>

          <p><strong>DMA method:</strong></p>
          <p>For memory-to-memory on the 8237, each byte requires 2 bus cycles (read from source + write to destination ‚Äî the DMAC uses its internal temp register).</p>
          <p>Total bus cycles = 256 √ó 2 = 512 cycles. Plus a few cycles for bus request/grant overhead (‚âà 4‚Äì5 cycles).</p>
          <p>At 2 MHz: 517 √ó 500 ns = <strong>258,500 ns ‚âà 0.26 ms</strong></p>

          <p style="font-family:'IBM Plex Mono'; font-size:15px; color:var(--accent); margin-top:8px;">
            DMA is approximately <strong>10√ó faster</strong> for this transfer.
          </p>
          <p>And the CPU is free to do other work (in cycle-stealing mode) or can resume immediately after the DMA completes.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon amber">T5</span> Memory Bandwidth Calculation ‚Äî Pentium Burst <a href="#modern-dram" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05.1 Modern DRAM</a></h3>
      <p><strong>Given:</strong></p>
      <ul>
        <li>Pentium CPU with 64-bit (8-byte) data bus at 66 MHz</li>
        <li>Burst cycle: 2-1-1-1 (5 clock cycles for 4 accesses of 8 bytes each = 32 bytes)</li>
      </ul>
      <p><strong>Question:</strong> Calculate the burst transfer rate in MB/s.</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Step 1: Total bytes per burst:</strong> 4 accesses √ó 8 bytes = <strong>32 bytes</strong></p>
          <p><strong>Step 2: Time for one burst:</strong> 5 clocks √ó (1/66 MHz) = 5 √ó 15.15 ns = <strong>75.76 ns</strong></p>
          <p><strong>Step 3: Transfer rate:</strong></p>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            Rate = 32 bytes / 75.76 ns = <strong>422.4 MB/s</strong>
          </p>
          <p>Alternative formula: Rate = 8 bytes √ó 66 MHz / 2.5 (avg clocks per access) ‚âà 8 √ó 66M / (5/4) = 8 √ó 66M √ó 4/5 = <strong>422.4 MB/s</strong></p>
          <p style="color:var(--text-dim); font-size:13px;">For pipelined burst (1-1-1-1): Rate = 32 bytes / (4 √ó 15.15 ns) = 32/60.6 = <strong>528 MB/s</strong></p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon amber">T6</span> SDRAM Efficiency Comparison <a href="#modern-dram" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05.1 Modern DRAM</a></h3>
      <p><strong>Given:</strong> A CPU with ideal burst pattern 2-1-1-1 (5T total for 32-byte cache line fill at 66 MHz).</p>
      <p><strong>Memory types and their actual cycle patterns:</strong></p>
      <ul>
        <li>SDRAM: 3-1-1-1 + 2 overhead = 8T total</li>
        <li>EDO: 5-2-2-2 = 11T total</li>
        <li>FPM: 5-3-3-3 = 14T total</li>
      </ul>
      <p><strong>Question:</strong> Calculate the efficiency of each memory type and the actual transfer rate of SDRAM.</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Efficiency = Ideal cycles / Actual cycles:</strong></p>
          <ul>
            <li>SDRAM: 5 / 8 = <strong>62.5%</strong></li>
            <li>EDO: 5 / 11 = <strong>45.5%</strong></li>
            <li>FPM: 5 / 14 = <strong>35.7%</strong></li>
          </ul>
          <p><strong>SDRAM actual transfer rate:</strong></p>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            32 bytes / (8 √ó 15.15 ns) = 32 / 121.2 ns = <strong>264 MB/s</strong>
          </p>
          <p>Vs. ideal: 32 / (5 √ó 15.15) = 32 / 75.76 = 422.4 MB/s</p>
          <p>The efficiency ratio confirms: 264 / 422.4 ‚âà 62.5%</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon amber">T7</span> DDR Data Rate Calculation <a href="#modern-dram" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05.1 Modern DRAM</a></h3>
      <p><strong>Given:</strong></p>
      <ul>
        <li>DDR2 memory with 266 MHz I/O bus clock</li>
        <li>64-bit (8-byte) wide DIMM</li>
        <li>DDR = 2 transfers per clock cycle</li>
      </ul>
      <p><strong>Question:</strong> (a) What is the data rate per pin in Mbps? (b) What is the peak DIMM bandwidth in MB/s? (c) What DDR2 standard name is this (e.g., PC2-xxxx)?</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>(a) Data rate per pin:</strong></p>
          <p>266 MHz √ó 2 (both edges) = <strong>533 Mbps per pin</strong> ‚Üí this is DDR2-533</p>
          <p><strong>(b) Peak DIMM bandwidth:</strong></p>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            533 MT/s √ó 8 bytes = <strong>4264 MB/s ‚âà 4.2 GB/s</strong>
          </p>
          <p><strong>(c)</strong> This is <strong>PC2-4200</strong> (rounded from 4264). The "PC2" prefix indicates DDR2, and 4200 is the approximate peak bandwidth in MB/s.</p>
        </div>
      </details>
    </div>
  </div>

  <!-- DESIGN & ANALYSIS PRACTICE -->
  <div class="section" id="practice-design">
    <span class="section-num">PRACTICE ¬∑ DESIGN & ANALYSIS</span>
    <h2>Practice Problems: Design & Analysis</h2>

    <div class="card">
      <h3><span class="icon purple">D1</span> 8086 Word Access Scenario <a href="#8086-databus" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.5 Data Bus</a></h3>
      <p><strong>Question:</strong> The 8086 executes <code>MOV AX, [2001h]</code>. Describe exactly what happens on the bus. How many bus cycles? What are the values of BHE' and A0 in each cycle?</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p>This is a <strong>16-bit read from an ODD address</strong>. The 8086 cannot do this in a single bus cycle because the word straddles the even/odd bank boundary.</p>

          <p><strong>Bus Cycle 1: Read byte from address 2001h (odd byte)</strong></p>
          <ul>
            <li>Address = 2001h ‚Üí A0 = 1</li>
            <li>BHE' = 0 (odd bank enabled, data appears on D8‚ÄìD15)</li>
            <li>The CPU reads the byte from the odd bank into the <strong>lower byte of AX (AL)</strong></li>
          </ul>

          <p><strong>Bus Cycle 2: Read byte from address 2002h (even byte)</strong></p>
          <ul>
            <li>Address = 2002h ‚Üí A0 = 0</li>
            <li>BHE' = 1 (even bank enabled, data appears on D0‚ÄìD7)</li>
            <li>The CPU reads the byte from the even bank into the <strong>upper byte of AX (AH)</strong></li>
          </ul>

          <p><strong>Total: 2 bus cycles</strong> (vs. 1 cycle if the word were at an even address like 2000h).</p>
          <p>This is why alignment matters ‚Äî this instruction takes <strong>twice as long</strong> as <code>MOV AX, [2000h]</code>.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D2</span> Interrupt Vector Table Lookup <a href="#interrupts" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß03 Interrupts</a></h3>
      <p><strong>Question:</strong> An 8259 PIC is configured with a base vector of 82h. A device on IR3 interrupts the CPU. What is the interrupt type number? What is the vector table address? If the ISR is located at CS:IP = 0000:3000h, what values are stored in the vector table?</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Type number:</strong> Base vector + IR number = 82h + 3 = <strong>85h (133 decimal)</strong></p>

          <p><strong>Vector table address:</strong> Type √ó 4 = 85h √ó 4 = <strong>214h</strong></p>

          <p><strong>Values stored at vector table (little-endian):</strong></p>
          <ul>
            <li>Address 214h: IP low byte = <code>00h</code></li>
            <li>Address 215h: IP high byte = <code>30h</code></li>
            <li>Address 216h: CS low byte = <code>00h</code></li>
            <li>Address 217h: CS high byte = <code>00h</code></li>
          </ul>
          <p>So the 4 bytes at 00214h‚Äì00217h would be: <code>00 30 00 00</code></p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D3</span> DMA Transfer Sequence Trace <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <p><strong>Question:</strong> A floppy disk controller connected to DREQ1 of an 8237 needs to transfer 512 bytes into memory starting at address 8000h. Describe the complete sequence of events from the moment the FDC is ready until the transfer completes.</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Setup (done by CPU before transfer):</strong></p>
          <ol>
            <li>CPU programs 8237 Channel 1: base address = 8000h, word count = 511 (512 transfers, count is N-1), mode = single transfer, I/O-to-memory, address increment.</li>
            <li>CPU unmasks Channel 1.</li>
          </ol>

          <p><strong>Transfer sequence (repeated 512 times):</strong></p>
          <ol>
            <li>FDC has a byte ready ‚Üí asserts <strong>DREQ1</strong></li>
            <li>8237 sees DREQ1 active ‚Üí asserts <strong>HRQ</strong> to CPU</li>
            <li>CPU completes current bus cycle ‚Üí tri-states buses ‚Üí asserts <strong>HLDA</strong></li>
            <li>8237 takes control of the bus:</li>
            <ul>
              <li>Outputs address 8000h (A0‚ÄìA7 on address pins, A8‚ÄìA15 via DB0‚Äì7 latched by ADSTB)</li>
              <li>Asserts <strong>DACK1'</strong> to acknowledge the FDC</li>
              <li>Simultaneously asserts <strong>IOR'</strong> (to read from FDC) and <strong>MEMW'</strong> (to write to memory)</li>
              <li>Data flows directly from FDC ‚Üí data bus ‚Üí memory</li>
            </ul>
            <li>8237 increments current address (8001h), decrements word count (510)</li>
            <li>In single transfer mode: 8237 releases bus (HRQ low), CPU gets bus back</li>
            <li>Repeat for next byte when FDC asserts DREQ1 again</li>
          </ol>

          <p><strong>Completion:</strong></p>
          <ol start="8">
            <li>After 512th transfer, word count reaches FFFFh (underflow from 0000h)</li>
            <li>8237 asserts <strong>EOP'</strong> (End of Process)</li>
            <li>Channel 1 is automatically masked (disabled)</li>
            <li>8237 can optionally interrupt the CPU (if TC interrupt is configured) to signal completion</li>
          </ol>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D4</span> DRAM Refresh Timing <a href="#dram-refresh" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß02.2 Refresh</a></h3>
      <p><strong>Question:</strong> A DRAM has 512 rows and requires all rows to be refreshed within 8 ms. If using distributed refresh, what is the maximum time between individual refresh cycles? If each refresh cycle takes 200 ns, what percentage of the bus time is consumed by refresh?</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Maximum interval between refresh cycles:</strong></p>
          <p>All 512 rows must be refreshed in 8 ms.</p>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            t_interval = 8 ms / 512 = <strong>15.625 ¬µs</strong> per row
          </p>
          <p>So one row must be refreshed every 15.625 ¬µs.</p>

          <p><strong>Bus time consumed by refresh:</strong></p>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            Refresh overhead = 200 ns / 15,625 ns = <strong>1.28%</strong>
          </p>
          <p>This is quite small ‚Äî distributed refresh has minimal impact on system performance, which is why it's preferred over burst refresh in most systems.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D5</span> Complete System Trace: What Happens When You Press a Key? <a href="#pc-arch" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05 PC/XT</a></h3>
      <p><strong>Question:</strong> In an IBM PC/XT, trace what happens from the moment a key is pressed on the keyboard until the CPU processes it. Mention the specific chips involved.</p>

      <details style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <ol>
            <li><strong>Keyboard controller</strong> (8255 PPI or dedicated keyboard controller) detects the keypress and places the scan code in its output register.</li>
            <li>The keyboard controller asserts its interrupt line, which is connected to <strong>IR1 of the 8259 PIC</strong>.</li>
            <li>The <strong>8259</strong> evaluates priority. If IR1 is the highest unmasked pending interrupt, it asserts <strong>INT</strong> ‚Üí connected to the 8088's <strong>INTR</strong> pin.</li>
            <li>The <strong>8088</strong> finishes its current instruction, checks INTR, and if IF=1, begins the interrupt acknowledge sequence.</li>
            <li>8088 sends two <strong>INTA'</strong> pulses. On the second pulse, the 8259 places the <strong>type number</strong> (e.g., 09h for IR1 in the PC/XT configuration) on D0‚ÄìD7.</li>
            <li>The 8088 reads type 09h, computes vector address = 09h √ó 4 = <strong>24h</strong>.</li>
            <li>8088 pushes FLAGS, CS, IP onto the stack, then loads CS:IP from addresses 00024h‚Äì00027h ‚Äî branching to the <strong>keyboard ISR</strong>.</li>
            <li>The ISR reads the scan code from the keyboard controller's I/O port (e.g., port 60h using <code>IN AL, 60h</code>), processes it, stores it in the keyboard buffer in RAM.</li>
            <li>The ISR sends an <strong>End-of-Interrupt (EOI)</strong> command to the 8259 (writing 20h to port 20h).</li>
            <li>The ISR executes <strong>IRET</strong>, restoring IP, CS, FLAGS ‚Äî the CPU returns to whatever it was doing before.</li>
          </ol>
        </div>
      </details>
    </div>


    <div class="card">
      <h3><span class="icon purple">D6</span> Interrupt Request Circuit Analysis <a href="#interrupts" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß03 Interrupts</a></h3>
      <p><strong>Question (from Jan 22 lecture):</strong> The diagram shows a simple interrupt circuit: a D flip-flop (DQ=VCC, CLK=device request, RESET=INTA'), connected to a 74LS244 buffer (enable=INTA') that outputs a hardwired type number onto D0-D7. The type number is hardwired as 10000010 (82h). Explain: (a) Why does sending the type number on the first INTA' not cause a problem? (b) What is the vector table address for this device?</p>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>(a)</strong> During the first INTA' pulse, the CPU tri-states the data bus ‚Äî it does NOT read from it. The type number appearing on the bus during the first INTA' causes no conflict because nothing else is driving the bus. The CPU only latches the data bus during the <strong>second</strong> INTA' pulse. So the type number is sent twice (once ignored, once read), and the circuit works correctly with a simpler design (no need to distinguish first from second INTA').</p>
          <p><strong>(b)</strong> Vector table address = type number √ó 4 = 82h √ó 4 = <strong>208h</strong>. The ISR's IP is stored at 00208h-00209h and CS at 0020Ah-0020Bh.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D7</span> 8259 Cascading: Available Interrupt Lines <a href="#8259" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß03.1 8259 PIC</a></h3>
      <p><strong>Question:</strong> You need to support 20 interrupt sources. How many 8259 chips do you need? How many interrupt lines are actually available? Draw the connection hierarchy.</p>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p>One 8259 gives 8 lines. With cascading, each slave uses one IR line on the master. So:</p>
          <p><strong>1 master + 2 slaves</strong> = 3 chips total. But:</p>
          <ul>
            <li>Master has 8 IR lines, 2 used by slaves ‚Üí <strong>6 available</strong> on master</li>
            <li>Slave 1: 8 lines available</li>
            <li>Slave 2: 8 lines available</li>
            <li>Total: 6 + 8 + 8 = <strong>22 available lines</strong> (enough for 20)</li>
          </ul>
          <p>The IBM PC/XT used 1 chip (8 lines). The PC/AT expanded to 2 chips: master + slave on IR2 ‚Üí <strong>15 available</strong> (8 + 8 ‚àí 1).</p>
          <p>For 64 lines (maximum): 1 master + 8 slaves = 9 chips. Master's 8 IR lines all connect to slaves ‚Üí 0 lines on master, 8 √ó 8 = 64 on slaves.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D8</span> DMA Block Transfer ‚Äî Worst Case Timing (from Jan 29 in-class problem) <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <p><strong>Given:</strong> 8237 DMAC at 4 MHz. Block transfer of 256 bytes. Start address is NOT on a 256-byte boundary (worst case).</p>
      <p><strong>Question:</strong> Calculate the total transfer time.</p>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Key insight (worst case):</strong> Since the start address is NOT boundary-aligned, incrementing through 256 bytes will cross a 256-byte boundary where A8 changes. This means S1 (full address output) is needed TWICE.</p>
          <p>Each DMA state = 1/(4 MHz) = <strong>250 ns</strong></p>
          <p><strong>Breakdown:</strong></p>
          <ul>
            <li>2 transfers with S1-S2-S3-S4 (4 states each) = 2 √ó 4 = 8 states</li>
            <li>254 transfers with S2-S3-S4 (3 states each) = 254 √ó 3 = 762 states</li>
          </ul>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            Total states = 8 + 762 = <strong>770 states</strong><br>
            Total time = 770 √ó 250 ns = <strong>192,500 ns ‚âà 192.5 ¬µs</strong>
          </p>
          <p style="color:var(--text-dim); font-size:13px;">Add S0 overhead (waiting for HLDA) and EOP at the end for a more precise answer, but the transfer itself is 770 states.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D9</span> DMA Single Transfer ‚Äî CPU Interleaved Timing <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <p><strong>Given:</strong> Same 8237 at 4 MHz, 8088 also at 4 MHz. Single transfer mode, 256 bytes. Best case: CPU takes exactly 1 machine cycle (4 T-states) between DMA transfers.</p>
      <p><strong>Question:</strong> Calculate total transfer time and compare to block mode.</p>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p>In single transfer mode, after each DMA transfer the bus returns to the CPU for at least one machine cycle.</p>
          <p><strong>Pattern:</strong> DMA(S1-S4) + CPU(4T) + DMA(S2-S4) + CPU(4T) + DMA(S2-S4) + ... + CPU(4T) + DMA(S2-S4)</p>
          <p><strong>Breakdown:</strong></p>
          <ul>
            <li>1st DMA transfer: 4 S-states</li>
            <li>255 subsequent DMA transfers: 3 S-states each (assuming same page ‚Äî simplified)</li>
            <li>255 CPU machine cycles interleaved: 4 T-states each</li>
          </ul>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            DMA states: 4 + (255 √ó 3) = 769 states<br>
            CPU states: 255 √ó 4 = 1020 T-states<br>
            Total = (769 + 1020) √ó 250 ns = 1789 √ó 250 ns = <strong>447,250 ns ‚âà 447.3 ¬µs</strong>
          </p>
          <p>Compare to block mode: ~192.5 ¬µs. Single transfer is <strong>~2.3√ó slower</strong>, but the CPU gets to execute ~255 instructions during the transfer.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D10</span> Divide-by-3 Circuit Design <a href="#8284-clock" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.2 Clock Gen</a></h3>
      <p><strong>Question (from Jan 8 lecture ‚Äî Sir Clem explicitly mentioned this as a quiz question):</strong> Design a divide-by-3 circuit using flip-flops that produces a 33% duty cycle output.</p>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>Approach:</strong> Use a 2-bit counter (two D flip-flops) that counts in sequence: 00 ‚Üí 01 ‚Üí 10 ‚Üí 00 (mod-3 counter).</p>
          <p><strong>State table:</strong></p>
          <div class="table-wrap">
            <table style="font-size:13px;">
              <thead><tr><th>Current (Q1 Q0)</th><th>Next (Q1 Q0)</th><th>Output</th></tr></thead>
              <tbody>
                <tr><td>00</td><td>01</td><td>1 (HIGH)</td></tr>
                <tr><td>01</td><td>10</td><td>0 (LOW)</td></tr>
                <tr><td>10</td><td>00</td><td>0 (LOW)</td></tr>
              </tbody>
            </table>
          </div>
          <p style="margin-top:8px;">Output is HIGH for 1 state out of 3 ‚Üí <strong>33.3% duty cycle</strong>. The output signal toggles at 1/3 the input frequency.</p>
          <p><strong>Logic equations (from K-maps):</strong></p>
          <p style="font-family:'IBM Plex Mono'; font-size:13px;">D0 = Q1' ¬∑ Q0'<br>D1 = Q0<br>Output = Q1' ¬∑ Q0' (same as D0)</p>
          <p style="color:var(--text-dim); font-size:13px;">The state 11 is unused ‚Äî add logic to self-correct: if 11 occurs, force next state to 00. This can be done by ANDing Q1'¬∑Q0' for D0 (which already handles it since D0=0 when Q1=Q0=1).</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D11</span> 50% Duty Cycle Maximum Frequency <a href="#8284-clock" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß01.2 Clock Gen</a></h3>
      <p><strong>Question (from Jan 8 lecture):</strong> The 8088 requires minimum clock low time (tCL) = 118 ns and minimum clock high time (tCH) = 69 ns. If you can only produce a 50% duty cycle clock, what is the maximum frequency you can run the 8088 at?</p>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p>With 50% duty cycle, tCH = tCL = T/2.</p>
          <p>The binding constraint is the <strong>longer</strong> minimum: tCL(min) = 118 ns.</p>
          <p>With 50% duty cycle: T/2 ‚â• 118 ns ‚Üí T ‚â• 236 ns</p>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            f(max) = 1/T = 1/236 ns ‚âà <strong>4.24 MHz</strong>
          </p>
          <p>This is below the rated 5 MHz. With a 33% duty cycle clock: tCL = 2T/3 ‚Üí 2T/3 ‚â• 118 ns ‚Üí T ‚â• 177 ns ‚Üí f ‚â§ 5.65 MHz. And tCH = T/3 ‚Üí T/3 ‚â• 69 ns ‚Üí T ‚â• 207 ns ‚Üí f ‚â§ 4.83 MHz. The binding constraint is tCH, giving ~4.83 MHz ‚âà the rated 5 MHz. This is exactly why the 33% duty cycle exists.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D12</span> DMA Memory-to-Memory Transfer Analysis <a href="#dma" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß04 DMA</a></h3>
      <p><strong>Question:</strong> The 8237 is programmed for memory-to-memory transfer. Ch0 base address = 1000h, Ch1 base address = 5000h, Ch1 word count = 255 (256 bytes). The DMAC runs at 4 MHz.</p>
      <p>(a) Which channel controls the source? Which controls the destination?</p>
      <p>(b) How many DMA states per byte transfer?</p>
      <p>(c) Calculate total transfer time.</p>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>(a)</strong> Ch0 = <strong>source</strong> (provides the read address). Ch1 = <strong>destination</strong> (provides the write address). Ch1's word count controls the transfer length (Ch0's word count is "don't care" in mem-to-mem mode).</p>
          <p><strong>(b)</strong> Each byte requires two bus cycles: read from source (S1-S2-S3-S4) + write to destination (S1-S2-S3-S4) = <strong>8 states per byte</strong>.</p>
          <p><strong>(c)</strong></p>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            Total states = 256 bytes √ó 8 states = <strong>2048 states</strong><br>
            State time = 1/(4 MHz) = 250 ns<br>
            Total time = 2048 √ó 250 ns = <strong>512,000 ns = 512 ¬µs</strong>
          </p>
          <p style="color:var(--text-dim); font-size:13px;">Note: Ch0 can be in "Hold" mode (address doesn't change) ‚Äî used for memory initialization (fill a block with a constant value).</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D13</span> DDR Generation Identification <a href="#modern-dram" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05.1 Modern DRAM</a></h3>
      <p><strong>Question:</strong> A student observes a memory module with the following specs: 1.5V, 8 banks, 8n prefetch, differential DQS only, supports write leveling, uses a fly-by bus topology, has a ZQ calibration pin. (a) Which DDR generation is this? (b) If it has a data rate of 1066 Mbits/s per pin, what would its typical JEDEC latency be? (c) What is the actual CAS latency in nanoseconds?</p>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <p><strong>(a)</strong> <strong>DDR3.</strong> The clues: 1.5V (DDR2 is 1.8V, DDR4 is 1.2V), 8n prefetch (DDR2 is 4n), fly-by topology (DDR2 uses T), write leveling (DDR2 doesn't have it), ZQ pin (DDR2 uses off-chip OCD).</p>
          <p><strong>(b)</strong> DDR3-1066: typical JEDEC latency = <strong>7-7-7-20</strong> (CL-tRCD-tRP-tRAS).</p>
          <p><strong>(c)</strong> The I/O bus frequency = 1066 / 2 = 533 MHz. One clock cycle = 1/533 MHz = 1.875 ns.</p>
          <p style="font-family:'IBM Plex Mono'; font-size:14px; color:var(--accent);">
            CAS latency = 7 √ó 1.875 ns ‚âà <strong>13.1 ns</strong>
          </p>
          <p style="color:var(--text-dim); font-size:13px;">Compare to DDR2-533 (CL=4): 4 √ó (1/266 MHz) = 4 √ó 3.76 ns = 15 ns. So DDR3-1066 is actually <em>faster</em> in absolute time despite the higher CL number.</p>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D14</span> PC/XT Memory Map & I/O Address Identification <a href="#pc-arch" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05 PC/XT</a></h3>
      <p><strong>Question:</strong> For each address, identify what device or memory region is being accessed:</p>
      <ul>
        <li>(a) Memory address B8000h</li>
        <li>(b) I/O address 0040h</li>
        <li>(c) Memory address 00024h</li>
        <li>(d) I/O address 0021h</li>
        <li>(e) Memory address FFFF0h</li>
        <li>(f) I/O address 0061h</li>
      </ul>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Solution</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <ul>
            <li><strong>(a) B8000h:</strong> CGA display buffer start address (within the B8000h‚ÄìBCFFFh range, 16 KB used for Color Graphics Adapter)</li>
            <li><strong>(b) 0040h:</strong> 8253 PIT Counter 0 register (the 8253 occupies 0040h‚Äì0043h)</li>
            <li><strong>(c) 00024h:</strong> Interrupt Vector Table ‚Äî this is the vector for Type 9 (9 √ó 4 = 36 = 24h), which is IRQ1 = <strong>keyboard interrupt</strong> in the PC/XT</li>
            <li><strong>(d) 0021h:</strong> 8259 PIC data register / OCW/ICW port (the 8259 occupies 0020h‚Äì0021h)</li>
            <li><strong>(e) FFFF0h:</strong> CPU reset vector ‚Äî this is the first instruction the 8088 executes on power-up/reset (CS=FFFFh, IP=0000h ‚Üí physical address FFFF0h). Located in the BIOS ROM.</li>
            <li><strong>(f) 0061h:</strong> 8255 PPI Port B ‚Äî controls speaker gate, cassette motor, read switch settings (0060h‚Äì0063h)</li>
          </ul>
        </div>
      </details>
    </div>

    <div class="card">
      <h3><span class="icon purple">D15</span> DDR Architecture Comparison ‚Äî Fill in the Blanks <a href="#modern-dram" style="float:right;font-size:11px;color:var(--text-dim);text-decoration:none;font-weight:500;opacity:0.7;" title="Jump to source section">üìñ ¬ß05.1 Modern DRAM</a></h3>
      <p><strong>Question:</strong> Complete this table from memory:</p>
      <div class="table-wrap">
        <table style="font-size:13px;">
          <thead><tr><th>Feature</th><th>DDR</th><th>DDR2</th><th>DDR3</th><th>DDR4</th></tr></thead>
          <tbody>
            <tr><td>Prefetch</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
            <tr><td>Voltage</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
            <tr><td>I/O buffer vs core</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
            <tr><td>Data Strobe</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
            <tr><td>Termination</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
            <tr><td>Impedance Cal.</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
            <tr><td>Topology</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
          </tbody>
        </table>
      </div>

      <details open style="margin-top:12px;">
        <summary style="cursor:pointer; color:var(--accent); font-size:13px;">Show Answer</summary>
        <div style="margin-top:12px; padding:16px; background:var(--surface2); border-radius:8px;">
          <div class="table-wrap">
            <table style="font-size:13px;">
              <thead><tr><th>Feature</th><th>DDR</th><th>DDR2</th><th>DDR3</th><th>DDR4</th></tr></thead>
              <tbody>
                <tr><td>Prefetch</td><td><strong>2n</strong></td><td><strong>4n</strong></td><td><strong>8n</strong></td><td><strong>8n</strong></td></tr>
                <tr><td>Voltage</td><td><strong>2.5V</strong></td><td><strong>1.8V</strong></td><td><strong>1.5V</strong></td><td><strong>1.2V</strong></td></tr>
                <tr><td>I/O buffer vs core</td><td><strong>Same (1√ó)</strong></td><td><strong>2√ó core</strong></td><td><strong>4√ó core</strong></td><td><strong>4√ó core</strong></td></tr>
                <tr><td>Data Strobe</td><td><strong>Single DQS</strong></td><td><strong>Differential DQS</strong></td><td><strong>Differential only</strong></td><td><strong>Differential only</strong></td></tr>
                <tr><td>Termination</td><td><strong>Module resistors</strong></td><td><strong>On-die (ODT)</strong></td><td><strong>On-die (ODT)</strong></td><td><strong>On-die (ODT)</strong></td></tr>
                <tr><td>Impedance Cal.</td><td><strong>None</strong></td><td><strong>Off-chip (OCD)</strong></td><td><strong>On-chip (ZQ pin)</strong></td><td><strong>On-chip (ZQ)</strong></td></tr>
                <tr><td>Topology</td><td><strong>‚Äî</strong></td><td><strong>T / Star</strong></td><td><strong>Fly-by</strong></td><td><strong>Fly-by</strong></td></tr>
              </tbody>
            </table>
          </div>
          <p style="margin-top:8px; color:var(--text-dim); font-size:13px;"><strong>Memory aid:</strong> Prefetch doubles each gen (2‚Üí4‚Üí8‚Üí8). Voltage drops ~0.3V each gen (2.5‚Üí1.8‚Üí1.5‚Üí1.2). Strobe goes single‚Üídifferential. Termination moves from board‚Üímodule‚Üídie. Calibration moves from external‚Üíon-chip.</p>
        </div>
      </details>
    </div>

    <!-- Final study note -->
    <div style="margin-top:48px; padding:28px; background:linear-gradient(135deg, rgba(59,130,246,0.08), rgba(139,92,246,0.08)); border-radius:16px; border:1px solid var(--border);">
      <h3 style="color:var(--text-bright); margin-bottom:12px; font-size:18px;">üìã Final Pre-Exam Checklist</h3>
      <ul style="list-style:none; padding:0;">
        <li style="padding:4px 0; font-weight:600; color:var(--accent); margin-top:8px;">‚Äî 8086/8088 Architecture ‚Äî</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain the difference between 8086 and 8088 without notes?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you draw the 8088 minimum mode block diagram from memory?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you calculate CLK and PCLK from a given crystal frequency?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you compute max memory access time given timing parameters + delays?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you determine how many wait states are needed for a given memory?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain the BHE'/A0 encoding table and alignment penalty?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain DEN'/DT/R' and the IO/M' vs M/IO' inversion?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you design a divide-by-3 circuit? (Sir Clem said this will be on the quiz!)</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you calculate max frequency with a 50% duty cycle clock?</li>

        <li style="padding:4px 0; font-weight:600; color:var(--accent); margin-top:12px;">‚Äî DRAM Fundamentals ‚Äî</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you trace a DRAM read cycle (RAS ‚Üí CAS ‚Üí Data)?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain all 3 refresh modes and when you'd use each?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you calculate refresh overhead for distributed refresh?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain the data window problem and how EDO solves it?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain the 2-1-1-1 burst cycle and pipeline burst?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you calculate memory bandwidth and efficiency for different technologies?</li>

        <li style="padding:4px 0; font-weight:600; color:var(--accent); margin-top:12px;">‚Äî Interrupts ‚Äî</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you trace the full external interrupt sequence (INTR ‚Üí INTA ‚Üí IVT ‚Üí ISR ‚Üí IRET)?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you compute a vector table address from a type number?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you draw an interrupt request circuit with D-FF + 74LS244?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain why 8259 devices don't need individual DACK lines?</li>

        <li style="padding:4px 0; font-weight:600; color:var(--accent); margin-top:12px;">‚Äî DMA (8237) ‚Äî</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain why DMA is faster than CPU-based transfer with numbers?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you trace a DMA I/O-to-memory transfer sequence?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain single vs block vs demand DMA transfer modes?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you name the 4 transfer types and their active control signals?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain mem-to-mem: Ch0=source, Ch1=dest, Temp Register, 8 states?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain the First/Last FF and how to program a 16-bit DMA register?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you calculate DMA block transfer worst-case timing (S1-S4 vs S2-S4)?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain DMA cascading (slave HRQ‚Üímaster DREQ, master DACK‚Üíslave HLDA)?</li>

        <li style="padding:4px 0; font-weight:600; color:var(--accent); margin-top:12px;">‚Äî PC/XT Architecture ‚Äî</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you name every support chip (8284, 8259, 8237, 8253, 8255, 8288) and its role?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you identify the I/O address ranges for 8237, 8259, 8253, 8255?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you draw the PC/XT memory map (IVT, 640K, display buffer, BIOS)?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain how DRAM refresh works via 8253 Ch1 ‚Üí DMA Ch0?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you identify the 8253 PIT channels (Ch0=tick, Ch1=refresh, Ch2=speaker)?</li>

        <li style="padding:4px 0; font-weight:600; color:var(--accent); margin-top:12px;">‚Äî DDR Memory (DDR1‚ÄìDDR4) ‚Äî</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain how DDR doubles bandwidth vs SDR (both clock edges)?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain DDR2's 4n prefetch and why I/O runs at 2√ó core?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain differential DQS (DDR2) and why it's better than single DQS?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain On-Die Termination (ODT) and why it's switch-controlled?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain DDR3's fly-by topology, write leveling, and read leveling?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you explain the DDR3 latency paradox (higher numbers but same/lower ns)?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you fill in the DDR evolution table (prefetch, voltage, strobe, topology)?</li>
        <li style="padding:4px 0; color:var(--text);">‚òê Can you calculate DDR data rate and DIMM bandwidth from bus frequency?</li>
      </ul>
    </div>
  </div>
</div>

<script>
// Active nav highlighting on scroll
const sections = document.querySelectorAll('.section');
const navLinks = document.querySelectorAll('.nav a');

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      navLinks.forEach(link => link.classList.remove('active'));
      const activeLink = document.querySelector(`.nav a[href="#${entry.target.id}"]`);
      if (activeLink) activeLink.classList.add('active');
    }
  });
}, { rootMargin: '-20% 0px -70% 0px' });

sections.forEach(section => observer.observe(section));
</script>
</body>
</html>
